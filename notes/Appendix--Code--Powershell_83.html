<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Powershell</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Powershell</h1><br/><p>[OSCP 22-29]</p><p></p><p><h1>Operators</h1></p><p><h2>Logical</h2></p><p><h3>And</h3></p><p><strong>-and</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong><h3>Or</h3><strong></strong></p><p><strong>-or</strong></p><p></p><p><em>Find-InterestingDomainAcl -ResolveGuids | Where-Object { $_.IdentityReferenceName -eq &quot;ryan&quot; -or $_.IdentityReferenceName -eq &quot;alex&quot; } | Select-Object IdentityReferenceName, ObjectDN, ActiveDirectoryRights</em><em></em></p><p><em></em></p><p><span style="color:#8ff0a4;text-decoration:underline;">Alternative (-in)</span>: If you&#39;re using PowerShell 3.0 or newer, a cleaner and more scalable way (especially with many names) is to use the <strong>-in</strong> operator.</p><p></p><p><em>$users = @(&quot;ryan&quot;, &quot;alex&quot;, &quot;chris&quot;)</em><em></em></p><p><em></em><em></em></p><p><em>Find-InterestingDomainAcl -ResolveGuids | Where-Object { $_.IdentityReferenceName -in $users } | Select-Object IdentityReferenceName, ObjectDN, ActiveDirectoryRights</em></p><p></p><p></p><p><h2>Comparison</h2></p><p><h3>String Matching</h3></p><p>Use <strong>-match</strong> / <strong>-notmatch</strong> (for Regex) or <strong>-like</strong> / <strong>-notlike</strong> (just a wildcard comparison). See <a href="https://stackoverflow.com/questions/36295016/powershell-match-vs-like">Match vs Like</a>.</p><p></p><p><em>Get-CimInstance -ClassName win32_service | Select Name,State,PathName,StartMode,State | Where-Object {$_.PathName -notlike &quot;C:\Windows*&quot;}</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Case Sensitive</span>: Prepending a <strong>c</strong> makes this <a href="https://stackoverflow.com/questions/26432076/how-to-do-a-case-sensitive-file-search-with-powershell">filtering case sensitive</a> (e.g <strong>-cmatch </strong>&amp; <strong>-clike</strong>)</p><p></p><p><em>Get-Childitem -Path C:\ | Where-Object {$_.Name -clike &quot;CAPS*&quot;}</em></p><p></p><p><a name="Escaping Special Characters"></a><h1>Escaping Special Characters</h1></p><p>The <a href="https://stackoverflow.com/questions/69837254/what-is-the-difference-between-the-escape-backtick-and-backslash-in-powe">escape character</a> may / may not vary based on the context in which it&#39;s used (e.g. if it&#39;s inside 2x quotes, single quotes, or not within quotes at all).</p><p></p><p>In Powershell, the Backtick ( <strong>`</strong> ) tends to work like the Backslash ( <strong>\</strong> ) does in Linux.</p><p></p><p>&#39;.\<strong><span style="color:#ff0000;">`</span></strong>[0;1e4c7df<strong><span style="color:#ff0000;">`</span></strong>]-2-0-40e10000-joed@krbtgt-DOMAIN.COM.kirbi’</p><p></p><p><a name="Arguments"></a><h1>Arguments</h1></p><p>Depending on the way you remotely connected to the machine, you may not be able to <a href="PrivEsc--Windows--RCE_33.html#Handling Interactive Prompts">interactively prompt</a> the user for input!</p><p></p><p>For example, if you were running the script using a non-interactive environment (i.e. WinRM) you can pass arguments (e.g. a file path) as a parameter without requiring interactive input.</p><p></p><p><em>powershell -File C:\path\to\test.ps1 -filePath &quot;C:\path\to\your\file.txt&quot;</em></p><p></p><p><h2>$args Automatic Variable</h2></p><p>This method is simpler and works well for basic scenarios where you just need to access a single argument. The <strong>param()</strong> method is preferred though.</p><p></p><p><em>$filePath = $args[0]</em><em></em></p><p><em></em><em></em></p><p><em>if (-not $filePath) {</em><em></em></p><p><em>    Write-Host &quot;File path is required.&quot;</em><em></em></p><p><em>    exit 1</em><em></em></p><p><em>}</em><em></em></p><p><em></em><em></em></p><p><em>Write-Host &quot;Processing file at: $filePath&quot;</em></p><p></p><p><h2>param()</h2></p><p>A more structured approach would be to use the <strong>param()</strong> block, which is cleaner and allows for better parameter validation and usage.</p><p></p><p><em>param (</em><em></em></p><p><em>    [Parameter(Mandatory=$true)]</em><em></em></p><p><em>    [string]$filePath</em><em></em></p><p><em>)</em><em></em></p><p><em></em><em></em></p><p><em>Write-Host &quot;Processing file at: $filePath&quot;</em></p><p></p><p><h3>Non-Mandatory Parameters</h3></p><p> If you want to make the argument optional in PowerShell, you can just omit the Mandatory attribute altogether. By default, parameters are not mandatory unless you specify it.</p><p></p><p><em>param (</em><em></em></p><p><em>    [string]$filePath</em><em></em></p><p><em>)</em><em></em></p><p><em></em><em></em></p><p><em>if ($filePath) {</em><em></em></p><p><em>    Write-Host &quot;Processing file at: $filePath&quot;</em><em></em></p><p><em>} else {</em><em></em></p><p><em>    Write-Host &quot;No file path provided.&quot;</em><em></em></p><p><em>}</em></p><p></p><p><h3>Parameters Without Values (switch)</h3><h3></h3></p><p><h3></h3>If you’re using <strong>param()</strong> to check for an argument flag (like a switch parameter) that doesn&#39;t take any values (e.g., just the presence or absence of the flag), you don’t need to put quotes around the flag in the <strong>param()</strong> block.</p><p></p><p>This is because a switch parameter is essentially a boolean flag that only checks for its presence, and it doesn&#39;t require a value. For example, see the <strong>$Help</strong> parameter specified below.</p><p></p><p><h3>Multiple Parameters</h3></p><p>Each parameter would be defined as a separate entry inside the <strong>param()</strong> block, and you can specify their types, whether they’re mandatory, and even default values if needed.</p><p></p><p><em>param (</em><em></em></p><p><em>    [string]$filePath,</em><em></em></p><p><em>    [switch]$Help,</em><em></em></p><p><em>    [int]$verbosity = 1  # Optional parameter with a default value</em><em></em></p><p><em>)</em><em></em></p><p><em></em><em></em></p><p><em># Handle the help menu</em><em></em></p><p><em>if ($Help) {</em><em></em></p><p><em>    Write-Host &quot;Help Menu: This script processes a file.&quot;</em><em></em></p><p><em>    Write-Host &quot;Parameters:&quot;</em><em></em></p><p><em>    Write-Host &quot;-filePath &lt;Path&gt;    : Path to the file to process.&quot;</em><em></em></p><p><em>    Write-Host &quot;-Help               : Displays this help message.&quot;</em><em></em></p><p><em>    Write-Host &quot;-verbosity &lt;Level&gt;  : Optional verbosity level (default is 1).&quot;</em><em></em></p><p><em>    exit</em><em></em></p><p><em>}</em><em></em></p><p><em></em><em></em></p><p><em># Processing file logic</em><em></em></p><p><em>if ($filePath) {</em><em></em></p><p><em>    Write-Host &quot;Processing file at: $filePath&quot;</em><em></em></p><p><em>} else {</em><em></em></p><p><em>    Write-Host &quot;No file path provided.&quot;</em><em></em></p><p><em>}</em><em></em></p><p><em></em><em></em></p><p><em># Handle verbosity</em><em></em></p><p><em>Write-Host &quot;Verbosity level is: $verbosity&quot;</em></p><p></p><p><h3>Parameter that takes CSVs (array)</h3></p><p>You can define a parameter that takes an array of strings with <strong>[string[]]</strong>. This still works even if the user only supplies a single value.</p><p></p><p>In PowerShell, when you pass a single value (like one file path) to an array parameter, it is treated as an array with one element.</p><p></p><p>If the user provides just one file path, the <strong>$filePaths</strong> parameter will be an array containing that single file path. The <strong>foreach</strong> loop will simply process it as the only element in the array.</p><p></p><p><em>param (</em><em></em></p><p><em>    [string[]]$filePaths,  # Accepts an array of file paths</em><em></em></p><p><em>    [switch]$Help,</em><em></em></p><p><em>)</em><em></em></p><p><em></em><em></em></p><p><em># Handle the help menu</em><em></em></p><p><em>if ($Help) {</em><em></em></p><p><em>    Write-Host &quot;Help Menu: This script processes multiple files.&quot;</em><em></em></p><p><em>    Write-Host &quot;Parameters:&quot;</em><em></em></p><p><em>    Write-Host &quot;-filePaths &lt;Path1,Path2,...&gt; : Comma-separated list of file paths to process.&quot;</em><em></em></p><p><em>    Write-Host &quot;-Help                        : Displays this help message.&quot;</em><em></em></p><p><em>    exit</em><em></em></p><p><em>}</em><em></em></p><p><em></em><em></em></p><p><em># Processing multiple file paths</em><em></em></p><p><em>if ($filePaths) {</em><em></em></p><p><em>    foreach ($filePath in $filePaths) {</em><em></em></p><p><em>        Write-Host &quot;Processing file at: $filePath&quot;</em><em></em></p><p><em>        # Add your script logic here for each file path</em><em></em></p><p><em>    }</em><em></em></p><p><em>} else {</em><em></em></p><p><em>    Write-Host &quot;No file paths provided.&quot;</em><em></em></p><p><em>}</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Running the Script</span>: <em>powershell -File C:\path\to\test.ps1 -filePaths &quot;C:\path\to\file1.txt&quot;, &quot;C:\path\to\file2.txt&quot;, &quot;C:\path\to\file3.txt&quot;</em></p><p></p><p>Or, if the paths are provided interactively, PowerShell will accept a comma-separated list as well:</p><p></p><p><em>powershell -File C:\path\to\test.ps1 -filePaths &quot;C:\path\to\file1.txt,C:\path\to\file2.txt&quot;</em></p><p></p><p><h3>Parameters in Functions</h3></p><p>In PowerShell, functions can have their own <strong>param()</strong> block, which allows them to define and handle parameters separately from the script’s global parameters.</p><p></p><p>This means you can have one main <strong>param()</strong> block for the script, &amp; another one inside the functions to handle parameters seperately from the script&#39;s global parameters.</p><p></p><p><h1>Execute Sequential Commands</h1></p><p>In Bash, <strong>&amp;&amp;</strong> executes the 2nd command after the 1st successfully finishes, &amp; <strong>;</strong> will execute the 2nd command regardless of whether or not the 1st was successful.</p><p></p><p><h2>Semi-colon ( ; )</h2></p><p>It works the same way in Powershell as it does in Bash.</p><p></p><p><em>Set-ExecutionPolicy -ExecutionPolicy Unrestricted; Get-ExecutionPolicy</em></p><p></p><p><h2>&amp;&amp; Equivilant</h2></p><p>Powershell doesn&#39;t have the built-in functionality to perform a condition check on the previous command, like <strong>&amp;&amp;</strong> does in Bash.</p><p></p><p>To replicate this feature, you can use <strong>if ($?) </strong>to check if the previous command succeeded (<strong>$?</strong> returns <strong>True</strong> if the last command was successful).</p><p></p><p><em>command1; if ($?) { command2 }</em></p><p></p><p><h1>Outputting Text to Console</h1></p><p>In PowerShell, <strong>Write-Host</strong> and <strong>echo</strong> both output text to the console, but they have different purposes and behavior.</p><p></p><p><h2>Write-Host</h2></p><p><strong>Purpose</strong>: Write-Host is specifically used for writing output directly to the console (the screen). It is designed for user interaction and display purposes.</p><p></p><p><strong>Effect on Pipeline</strong>: Write-Host does not send output to the pipeline. This means that whatever you output using Write-Host <span style="color:#ff0000;">can&#39;t be captured, redirected, or piped</span> to other commands.</p><p></p><p><strong>Use Case</strong>: It is often used when you want to show information to the user but don&#39;t need to pass that information to other commands.</p><p></p><p><em>Write-Host &quot;This is a message to the user&quot;</em></p><p></p><p><h3>Advantages vs echo</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">Direct User Interaction/Display</span>: Write-Host is specifically designed for user-facing messages. It writes directly to the console without affecting the pipeline.</p><p></p><p> This is useful when you need to display information purely for the user (like status updates, progress indicators, or error messages).</p><p></p><p>It’s great for UI-like messages that aren’t meant to be processed or used later. For example, you might use Write-Host to display &quot;Processing started...&quot; or &quot;Task completed successfully&quot; during script execution.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Clear Separation of Output</span>: Write-Host ensures that information intended for the user does not accidentally get sent down the pipeline and interfere with other commands.</p><p></p><p>This separates user messages from the data that is part of the pipeline, making your script more predictable and the pipeline will remain focused on functional data.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Clarity in Logging</span>: If your script is meant to show clear, formatted output to the user without any need for further processing, Write-Host can be simpler and more straightforward.</p><p></p><p>You’re not concerned with the data being part of the pipeline, and this helps avoid confusion about what output is for the user versus what output is functional and can be captured or piped.</p><p></p><p><h2>echo</h2></p><p><strong>Purpose</strong>: echo is an alias for the Write-Output cmdlet. Write-Output sends data to the output pipeline, meaning the data can be passed to other cmdlets, captured by variables, or redirected to files.</p><p></p><p><strong>Effect on Pipeline</strong>: Unlike Write-Host, echo sends its output to the pipeline, making it part of the normal output flow.</p><p></p><p>If no pipeline operation is happening (i.e., if you&#39;re just calling echo in the console), it will behave similarly to Write-Host, showing output in the console.</p><p></p><p><strong>Use Case</strong>: You typically use echo (or Write-Output) when you want to generate output that can be consumed by other commands or saved into variables, but you still want to display it to the user in the console.</p><p></p><p><h2>String Concatenation</h2></p><p>In PowerShell, the <strong>+</strong> operator is used for string concatenation, but when you use it in the <strong>Write-Host</strong> or <strong>echo</strong> command, it may not work as intended especially when strings contain special characters or newline symbols.</p><p></p><p>You can use <strong>Write-Host</strong> or <strong>echo</strong> with <span style="color:#ff0000;">multiple arguments</span> instead of using + for concatenation.</p><p></p><p><em>Write-Host &#39;powershell -File C:\path\to\charon.ps1 -groups &quot;HR&quot;, &quot;Development Team&quot;&#39; &quot;`n&quot;</em></p><p></p><p><h3>Using New Lines</h3></p><p>In PowerShell:</p><p><ul><li>Single quotes ( <strong>&#39; </strong>) create literal strings, meaning everything inside the quotes is treated as raw text.</li></ul></p><p><ul><li>Double quotes ( <strong>&quot;</strong> ) allow for variable expansion and escape sequences like &quot;n&quot; (new line), $variable`, etc.</li></ul></p><p></p><p>However, the <span style="color:#ff0000;">backtick</span> ( <strong>`</strong> ) is a special escape character in PowerShell that <span style="color:#ff0000;">works inside both</span> single-quoted and double-quoted strings.</p><p></p><p><em>Write-Host &#39;powershell -File C:\path\to\charon.ps1 -groups &quot;HR&quot;, &quot;Development Team&quot;`n&#39;</em></p></div>
</body>
</html>
