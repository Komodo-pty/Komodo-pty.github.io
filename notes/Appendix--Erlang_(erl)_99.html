<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Erlang (erl)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Erlang (erl)</h1><br/><p>[CTF D 25-27]</p><p></p><p><h1>Background</h1></p><p>Erlang is a programming language &amp; runtime environment. <strong>erl</strong> is the CLi for the Erlang runtime system. It starts an Erlang VM for programming.</p><p></p><p>Erlang typically uses <strong>.erl </strong>&amp; <strong>.hrl</strong> file extensions.</p><p></p><p><h2>Erlang Port Mapper Daemon (epmd)</h2></p><p>The Erlang Port Mapper Daemon (<strong>epmd</strong>) runs alongside Erlang-based Apps like <a href="Appendix--Erlang_(erl)_99.html#RabbitMQ">RabbitMQ</a>. It may be found on Nmap scans, &amp; uses <span style="color:#ff0000;">port </span><strong><span style="color:#ff0000;">4369</span></strong> by default.</p><p></p><p>This Daemon&#39;s job is to map Erlang node names (e.g. <strong>rabbit@hostname</strong>) to the TCP ports that they&#39;re listening on, enabling inter-node communication in an Erlang Cluster.</p><p></p><p><strong>epmd</strong> ensures that tools like <strong>rabbitmqctl</strong> &amp; other Erlang nodes can locate each other, even if ports are dynamically assigned.</p><p></p><p><h2>Use Case</h2></p><p>Erlang (erl) is primarily used to build highly scalable, fault-tolerant, and concurrent systems, especially in telecommunications and related industries.</p><p></p><p>It excels at handling large numbers of concurrent connections and distributed systems where reliability and low latency are crucial.</p><p></p><p><h1>Exploitation</h1></p><p><a name="Erlang Cookies"></a><h2>Cookies</h2></p><p>Erlang Cookies are used by Erlang-based Apps &amp; the <strong>erl</strong> CLi tool for authentication.</p><p></p><p>An Erlang Cookie can be used for <a href="https://hacktricks.boitatech.com.br/pentesting/4369-pentesting-erlang-port-mapper-daemon-epmd">RCE</a> &amp; sometimes PrivEsc. </p><p></p><p>Cookies are typically found at <strong>~/.erlang.cookie</strong>, but they may be elsewhere like in an Erlang-based App&#39;s directory (e.g. <strong>/var/lib/rabbitmq/.erlang.cookie</strong>)</p><p></p><p><a name="RabbitMQ"></a><h1>RabbitMQ Messaging System</h1></p><p><h2>Background</h2></p><p>FOSS Message Broker that facilitates communications between Apps by implementing <a href="Infrastructure_36.html#AMQP">AMQP</a>, but it also supports other protocols via plugins (e.g. MQTT, &amp; STOMP).</p><p></p><p>It&#39;s middleware that allows Apps to communicate even if they&#39;re not connected or available at the same time (<span style="color:#ff0000;">asynchronous</span>).</p><p></p><p>RabbitMQ works like a Post Office: Messages are sent, stored, &amp; delivered when the client is ready.</p><p></p><p>By default, RabbitMQ nodes have the format <strong>rabbit@hostname</strong>, &amp; this is how <strong>epmd</strong> maps them.</p><p></p><p><h3>Tech Stack</h3></p><p>The <strong>epmd</strong> (port 4369) service enables node discovery, &amp; is used by the <strong>rabbitmqctl</strong> CLi tool for Erlang-based administration.</p><p></p><p><strong>AMQP</strong> (port 5672) is “client facing” &amp; used for messaging functionality.</p><p></p><p><h3>rabbitmqctl</h3></p><p><strong>rabbitmqctl</strong> is a CLi tool for managing &amp; monitoring the RabbitMQ “broker”.</p><p></p><p>It interacts with the RabbitMQ node (an Erlang Process) to send commands to the App (e.g. <strong>rabbit@hostname</strong>) over Erlang&#39;s native protocol (via <strong>epmd</strong>), not AMQP.</p><p></p><p><strong>rabbitmqctl</strong> relies on <a href="Appendix--Erlang_(erl)_99.html#Erlang Cookies">Erlang Cookies</a> (shared secrets) for authentication, &amp; relies on <strong>epmd</strong> for discovering the RabbitMQ node&#39;s port.</p><p></p><p><h2>Exploitation</h2></p><p><span style="color:#060f94;text-decoration:underline;">LESSON</span>: I wouldn&#39;t have found this exploit if I didn&#39;t know how the target Software worked (mechanisms used). Generic Erlang exploitation methods didn&#39;t work in this case (e.g. <a href="https://hacktricks.boitatech.com.br/pentesting/4369-pentesting-erlang-port-mapper-daemon-epmd">Hacktricks: epmd</a>).</p><p></p><p>There weren&#39;t any explicit references to AMQP, but it&#39;s used by RabbitMQ. You need to consider the full tech stack if Recon doesn&#39;t give you any obvious attack vectors. </p><p></p><p><h3>Enumeration</h3></p><p><span class="subheading">Nodes</span>: Your external Nmap scan may show that the RabbitMQ node is running on the target, but you can confirm this locally on the target by running:</p><p></p><p><em>epmd -names</em></p><p></p><p><strong>epmd: up and running on port 4369 with data:</strong><strong></strong></p><p><strong>name rabbit at port 25672</strong></p><p></p><p><span class="subheading">Hostname</span>: You need to know the Hostname, since epmd uses it for mapping. <span style="color:#ff0000;">Add the Hostname to your </span><strong><span style="color:#ff0000;">/etc/hosts</span></strong> entry for this target machine. You can determine the target&#39;s Hostname with one of the following methods.</p><p><ol><li>Look at fully stabilized terminal</li></ol></p><p><ol><li><strong>hostname</strong> command</li></ol></p><p><ol><li>On some Linux distributions, <strong>/etc/hosts</strong> contains an entry for <strong>127.0.1.1</strong> which is mapped to your Hostname. This lets the local machine reference itselg using its Hostname without needing an external lookup.</li></ol></p><p></p><p><h3>Recon</h3></p><p>Follow the <a href="Infrastructure_36.html#AMQP">AMQP</a> Exploitation steps on <a href="https://exploit-notes.hdks.org/exploit/network/protocol/amqp-pentesting/">Exploit-Notes</a>. See this <a href="https://jaxafed.github.io/posts/tryhackme-rabbit_store/">example CTF</a>.</p><p></p><p>For example, the target&#39;s Hostname is “forge” so you added that to the <strong>/etc/hosts</strong> entry for this IP. Output the <a href="Appendix--Erlang_(erl)_99.html#Erlang Cookies">Erlang Cookie</a> &amp; use it&#39;s value for the following command.</p><p></p><p>This will list all users &amp; account descriptions (which may contain sensitive info).</p><p></p><p><em>sudo rabbitmqctl --erlang-cookie ‘COOKIE’ --node rabbit@forge status</em></p><p></p><p><em>sudo rabbitmqctl --erlang-cookie ‘COOKIE’ --node rabbit@forge</em> <em>list_users</em></p><p></p><p><h3>Retrieve Password Hash</h3></p><p>Output config data, including user hashes.</p><p></p><p><em>sudo rabbitmqctl --erlang-cookie &#39;UdEX5rcSZi5pg0ow&#39; --node rabbit@forge export_definitions /tmp/definitions.json</em></p><p></p><p><span class="subheading">Extract SHA256 Hash</span>: By default, RabbitMQ generates hashes using the following algorithm to calculate values for the  <strong>&quot;password_hash&quot;</strong> field.</p><p></p><p><strong>base64(&lt;4 byte salt&gt; + sha256(&lt;4 byte salt&gt; + &lt;password&gt;))</strong></p><p></p><p>The following command will isolate the SHA256 Hash with the salt removed (the 1st 8 characters are removed because in Hex, 2 characters represent 8 bits or 1 byte).</p><p></p><p><em>echo -n ‘PASSWORD_HASH’ | base64 -d | xxd -p -c 1000 | cut -c9-</em></p><p></p><p><span class="subheading">Cracking the Hash</span>: I *think* the same 4 byte salt is used in both places for this hashing algorithm. If this is the case, you can add the salt to wordlist entries to effectively remove it from the equation.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>:  <strong>john</strong> may be able to crack the password hash without seperating it from the password. This would mean that you can just crack the Extracted SHA256 hash.</p><p><ol><li>Identify the Salt: Find the first 8 Hex characters which are used for the salt.</li></ol></p><p></p><p><em>echo -n ‘PASSWORD_HASH’ | base64 -d | xxd -p -c 1000</em></p><p><ol><li>Mutate your wordlist by converting the entries to Hex &amp; prepending the salt to them.</li></ol></p><p><ol><li>Run <strong>john</strong> &amp; match the result to the clear-text password (comparing the line numbers in the mutated wordlist &amp; the OG wordlist).</li></ol></p><p></p><p></p><p></p><p></p></div>
</body>
</html>
