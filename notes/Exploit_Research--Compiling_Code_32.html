<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Compiling Code</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Compiling Code</h1><br/><p><a name="go static"></a><h1>Go Static Binaries</h1></p><p>&quot;Go creates static binaries by default unless you use cgo to call C code, in which case it will create a dynamically linked binary. Using cgo is more common than many people assume as the os/user and net packages use cgo, so importing either (directly or indirectly) will result in a dynamic binary.&quot; -<a href="https://www.arp242.net/static-go.html">Source</a></p><p></p><p>&quot;<span style="color:#ff0000;">Some systems do not really allow totally static binaries. Other work better if you use the system provided stuff </span> (e.g. name resolution). Disabling cgo makes sure no C code is used while  -static instructs the linker to statically link everything.&quot; -<a href="https://stackoverflow.com/questions/61319677/flags-needed-to-create-static-binaries-in-golang">Source</a></p><p></p><p><h2>Standard</h2></p><p><em>CGO_ENABLED=0 go build -ldflags=&quot;-extldflags=-static&quot; -o pspy_static main.go</em></p><p></p><p><h2>Special Config</h2></p><p>Modified the Standard command using the Repo&#39;s <strong>Makefile</strong> (in this case, it was for <a href="https://github.com/jpillora/chisel/blob/master/Makefile">Chisel</a>).</p><p></p><p>I used extra <strong>ldflags</strong> that were referenced at the top of the file, &amp; combined the default compilation command run by the <strong>Makefile</strong> with the Standard Static Compilation command referenced above.</p><p></p><p><em>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -trimpath ${GCFLAGS} ${ASMFLAGS}  -ldflags=&quot;-extldflags=-static -s -w ${XBUILD} -buildid=${BUILD} -X github.com/jpillora/chisel/share.BuildVersion=${VERSION}&quot; -o build/v1.10.0/59e5362e6bd6c0ea3e02f99209a1359416a952aa/bin/chisel-linux_static .</em></p><p></p><p><h1>Assembly (</h1><em><h1>nasm</h1></em><h1>)</h1></p><p>[OSCP 206]</p><p></p><p><h1>GCC</h1></p><p></p><p>Target may have diff ver of gcc (e.g <em>gcc-9</em>) or alternate compiler (e.g <em>g++</em>).</p><p></p><p>May be able to determine which compilers are present with-</p><p></p><p><em><span style="color:#ff0000;">apropos compile</span></em></p><p></p><p><h2>★</h2><h2>File Extensions</h2><h2>★</h2></p><p>You <span style="color:#ff0000;">NEED the correct file extension</span> to compile using GCC, which varies based on the language used &amp; the type of compilation you want to perform.</p><p></p><p>&quot;<em>gcc</em> chooses the language based on the file extension.&quot; So to compile C++ you can either use a file with a <strong>.cpp</strong> extension or just use <em>g++</em> to compile. To compile in C you need the<strong> .c</strong> extension. For C# you need <strong>.cs</strong>.</p><p></p><p>If a file has the wrong file extension, gcc will throw an error like:</p><p></p><p><strong>file not recognized: File format not recognized</strong></p><p></p><p><h2>Static Compilation </h2></p><p>Look up<a href="https://stackoverflow.com/questions/8692128/static-option-for-gcc"> gcc static</a>.</p><p></p><p>&quot;The <strong>-static</strong> option links a program statically, in other words it does not require a dependency on dynamic libraries at runtime in order to run.&quot;</p><p>“To achieve static linking <span style="color:#ff0000;">requires that the archive (.a) versions of your libraries exist on the system</span>. so /usr/lib/libc.a, /usr/lib/crt1.o, etc.”</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: One indication that a script needs to be statically compiled may be the <strong>.so</strong> file ext</p><p></p><p><a name="gcc static & shared"></a><h3>Shared Library</h3></p><p>There&#39;s a <a href="https://www.reddit.com/r/cpp_questions/comments/xu3z0l/static_vs_shared_lib/?rdt=64313">diff between static &amp; shared</a> libraries, but <span style="color:#ff0000;">both can be used to </span>the same end (<span style="color:#ff0000;">setup binaries that can be executed on a machine w/o a compiler</span>)!</p><p></p><p>Cannot use <strong>-static</strong> for a program being compiled with <strong>-shared</strong>.However, if an exploit uses multiple files, &amp; some are compiled with <strong>-shared</strong> you can compile the rest with <strong>-static</strong>. For example, see <a href="PrivEsc--Linux_29.html#static pwnkit">Pwnkit exploit</a>.</p><p></p><p><h1>Cross Compilation (Mingw-w64)</h1></p><p><h2>Background</h2></p><p><h3>Setup</h3></p><p>Kali comes pre-installed with some cross compilers, but there may be missing dependencies unless you install <a href="https://en.wikipedia.org/wiki/Mingw-w64">Mingw-w64</a> with-</p><p></p><p><em>sudo apt install mingw-w64</em></p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: Normal compiler rules still apply, so to compile a C++ program either use <em>g++</em> or a file with a <strong>.cpp </strong>extension.</p><p></p><p><h2>Usage</h2></p><p>Mingw-w64 can generate 32 bit and 64-bit executables for x86 under the target names<strong> i686-w64-mingw32</strong> and <strong>x86_64-w64-mingw32</strong>. Specific compilers are appended to that prefix, for example-</p><p></p><p><em><strong>x86_64-w64-mingw32-gcc</strong></em><em> /mnt/code/code/c/cpp/dll_hijack/r_shell.cpp --shared -o shell.dll</em></p><p></p><p><a name="Kernel Exploit Compilation"></a><h1>Kernel Exploit Error- </h1><strong><h1>&#39;GLIBC_2.34&#39; not found</h1></strong></p><p><a href="https://github.com/X0RW3LL/XenSpawn">XenSpawn</a> can be used when a kernel exploit you compiled is throwing these errors on the taret machine.</p><p></p><p><h2>Managing Container</h2></p><p><span style="color:#060f94;text-decoration:underline;">Naming Note</span>: Issue starting container with the name dirty_cow, is it the underscore?</p><p></p><p>For ex, named <strong>DirtyCow</strong>. 1st create it (if not already made), then start it.</p><p></p><p><em>sudo ./spawn.sh DirtyCow </em></p><p></p><p><em>sudo systemd-nspawn -M DirtyCow</em></p><p></p><p><h3>Exiting</h3></p><p>Can just type <strong>exit</strong></p><p></p><p>If something&#39;s wrong, can SIGKILL with <strong>^] </strong>three times within 1 second ( Ctrl + ]]] )</p><p></p><p><h3>Remove Container</h3></p><p>root@kali:~# <em>machinectl remove DirtyCow</em></p><p></p><p><h2>Compiliing Code</h2></p><p><h3>Setup</h3></p><p>Before starting container, or in another terminal</p><p><ol><li>Sign in as root</li><li>Nav to Container&#39;s root dir</li><li>Download exploit</li><li>Sign out as root</li></ol></p><p></p><p><em>sudo /bin/bash -p</em></p><p><em>cd /var/lib/machines/DirtyCow/root</em></p><p><em>/usr/bin/searchsploit -m 40839</em></p><p><em>exit</em></p><p></p><p><h3>Compile</h3></p><p>Start container (e.g <em>sudo systemd-nspawn -M DirtyCow</em> ) &amp; then inside the container-</p><p></p><p><em>gcc -pthread 40839.c -o dirty -lcrypt</em></p><p><em>exit</em></p><p></p><p><h3>File Transfer</h3></p><p>Either sign back in as root to nav to the dir (i.e <strong>/var/lib/machines/DirtyCow/root</strong>), or copy it to an accessible location &amp; assign R/W perms to your normal user account. Can then use python webserver, SMB, etc. </p><p></p><p><h1>Visual Studio- </h1><strong><h1>.sln </h1></strong><h1>&amp; </h1><strong><h1>.csproj</h1></strong></p><p>[Infrastructure 65]</p><p></p><p>The <span style="color:#ff0000;">most reliable</span> (&amp; intended) method is to <span style="color:#ff0000;">use a Windows machine</span> to compile the code with <span style="color:#ff0000;">Visual Studio</span>&#39;s <strong>Batch Build</strong> (not to be confused with VS Code).</p><p></p><p><h2>Using Linux Machine</h2></p><p>Depending on the project, you may be able to compile it on a Linux machine with <strong>dotnet</strong>.</p><p></p><p><em>dotnet build PROJECT.sln</em></p><p></p><p><h3>Limitations</h3></p><p>There are various reasons why you may not be able to compile using a Linux machine. In these cases you&#39;ll need <strong>Mono</strong> (for .NET Framework compatibility) or running a Windows VM.</p><p></p><p>For example, compilation won&#39;t work if your .sln contains:</p><p><ol><li>.NET Framework (pre-.NET Core) projects (like targeting .NET Framework 4.8)</li></ol></p><p><ol><li>C++ projects</li></ol></p><p><ol><li>Windows Forms or WPF (pre-.NET Core 3.0)</li></ol></p><p></p><p></p><p><a name="Compilation Troubleshooting"></a><h1>Compilation Troubleshooting</h1></p><p><h2>PATH Environment</h2></p><p><strong>error trying to execute ‘</strong>cc1<strong>’: execvp: No such file or directory</strong></p><p></p><p>Check the PATH for a misconfig, &amp; fix it if necessary. It could also indicate that a dependency wasn&#39;t installed.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: The file referenced may not need to be in the PATH itself. It may be loaded in by another program that is in the PATH.</p><p></p><p><em>echo $PATH</em><em></em></p><p><em>export PATH=</em>STUFF</p><p></p><p><em>find / -name “cc1*” 2&gt;/dev/null</em></p><p></p><p><h2>Workarounds</h2></p><p>For example, if the tool uses outdated dependencies.</p><p></p><p><h3>Pre-Compiled Release</h3></p><p>If you&#39;re downloading it from a Repo, there may be a pre-compiled release that you can use.</p><p></p><p><h3>Trick Makefile</h3></p><p>For example, the Makefule lists old packages (e.g. aclocal-1.15 but current is aclocal version 1.17).</p><p></p><p>You may be able to create symbolic links from the current package to a file with the specified name.</p><p></p><p><em>sudo ln -sf /usr/bin/aclocal /usr/bin/aclocal-1.15</em></p><p></p><p><h3>Edit Compilation Scripts</h3></p><p>Locate instances where old package names are used &amp; edit them to use the new name. For example, run the following in the Repo&#39;s directory &amp; use a tool like <strong>vim</strong> or <strong>sed</strong> to make the changes.</p><p></p><p><em>grep -Ri “aclocal-1.15” ./</em></p><p></p><p><h3>Install Old Packages</h3></p><p>May be able to insall the needed version, either by using your package manager &amp; explicitily listing the version (e.g. <strong>sudo apt install aclocal-1.15</strong>) or by tracking down the pkgs from other sources.</p><p></p><p><span style="color:#f66151;text-decoration:underline;">WARNING</span>: This isn&#39;t always possible, could be a security risk, &amp; could cause dependency issues for your system.</p><p></p><p><h3>Compile on Another Machine</h3></p><p>Use a machine which has the necessary SW. For example, <span style="color:#e01b24;">on the target machine</span> (as an added benefit, you wouldn&#39;t need to statically compile the tool if you&#39;re using the target machine).</p><p></p><p><h1>Tips</h1><ul><li>Compilation errors don&#39;t always matter! Ignore the haters, unless you tried the script &amp; it isn&#39;t working</li></ul></p><p></p><p>•★Find Compilers on Linux with- <em><span style="color:#ff0000;">apropos compile </span></em></p></div>
</body>
</html>
