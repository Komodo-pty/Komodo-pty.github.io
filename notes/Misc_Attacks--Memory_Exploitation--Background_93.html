<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Background</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Background</h1><br/><p>[CTF D 29-33]</p><p></p><p><h1>Example BoF Exploitation (THM- Obscure)</h1></p><p><h2>Initial Analysis</h2></p><p>Exfiltrate the SUID binary, &amp; run it through Decompilers (e.g. <a href="https://dogbolt.org/">dogbolt.org</a>). If you&#39;re allowed to use AI, you can use it to analyze the decompiled code quickly (<strong>grok</strong> seems to work better than <strong>ChatGPT</strong>).</p><p></p><p>In this case, there&#39;s a 128-byte buffer with an 8-byte Base Point Register, &amp; overflowing this buffer triggers the <strong>win()</strong> function to spawn a root shell.</p><p></p><p><h3>Necessary Information</h3></p><p>You need 3 pieces of information to exploit a BoF, which will be obtained in subsequent steps.</p><p><ol><li>Find a Vulnerable Function</li></ol></p><p><ol><li>Determine Padding Size (Offset)</li></ol></p><p><ol><li>Identify the address for the Target Function that you want to trigger</li></ol></p><p></p><p><h2>Determine Offset</h2></p><p>How many bytes do you need to overflow the vulnerable buffer to trigger the target function? In this example, the target is using a Base Point Register (<strong>rbp</strong> for 64-bit architecture).</p><p></p><p><h3>Find Vulnerable Buffer</h3></p><p>In this case, the buffer is 128 bytes (specified between brackets <strong>[ ]</strong> for C).</p><p></p><p><strong>void vuln(void)</strong><strong></strong></p><p><strong>{</strong><strong></strong></p><p><strong>	char local_88[</strong><strong><span style="color:#ff0000;">128</span></strong><strong>];</strong><strong></strong></p><p><strong>	</strong><strong><span style="color:#ff0000;">gets</span></strong><strong>(local_88);</strong><strong></strong></p><p><strong>}</strong></p><p>...</p><p><strong>void win(void)</strong><strong></strong></p><p><strong>{</strong><strong></strong></p><p><strong>	fwrite(&quot;Congrats, you made it on the box&quot;, 1, 0x20, stdout);</strong><strong></strong></p><p><strong>	system(&quot;/bin/sh&quot;);</strong><strong></strong></p><p><strong>	return;</strong><strong></strong></p><p><strong>}</strong></p><p></p><p><h3>Find Vulnerable Function</h3></p><p>In this case, the vulnerable function is <strong>vuln()</strong>, since it contains the buffer used for user input &amp; passes that user input into the <strong>gets()</strong> function.</p><p> </p><p> In C, the <strong>gets()</strong> function is VERY dangerous, so it was deprecated &amp; replaced with <strong>fgets()</strong>. This is because <strong>gets()</strong> has no parameter to specify the buffer size, &amp; will blindly write user input into RAM.</p><p></p><p><strong>gets()</strong> will write past the buffer &amp; overwrite adjacent memory. It&#39;s an infamous vector for BoF because it has <span style="color:#ff0000;">no Bounds Checking</span>.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Goal</span>: Leverage the vulnerable <strong>vuln()</strong> function to trigger the <strong>win()</strong> function, which will then spawn a shell utilizing this Binary&#39;s SUID permissions.</p><p></p><p><h3>Is Base Point Register Being Used?</h3></p><p>The binary may not use a <a href="Misc_Attacks--Memory_Exploitation--Background_93.html#Base Point Register">Base Point Register</a>, but if the binary does, then it&#39;ll need to be factored in when calculating your offset.</p><p></p><p>If you can&#39;t determine whether or not the Base Point Register is being used, you can try 1 payload with it factored into the Offset &amp; 1 payload where it&#39;s not factored into the Offset. (More likely to crash stuff if you use the wrong payload?)</p><p></p><p>If it is in use, the size of the Base Point Register will vary depending on the target&#39;s architecture which was used to compile this binary.</p><p></p><p>There are multiple methods for identifying the Base Point Register. The <span style="color:#ff0000;">most reliable</span> of these 3 methods is to use the <span style="color:#ff0000;">Debugger</span>. The other methods don&#39;t actually check if the Base Point Register has been optimized out, just what size would be based on Arch.</p><p></p><p><span style="color:#060f94;">★</span><span style="color:#8ff0a4;text-decoration:underline;">Using Debugger</span>: When this binary is run, it takes user input &amp; passes it to the vulnerable function. Inputting too many bytes will cause the binary to crash (I don&#39;t think there&#39;s a downside to overshooting it?)</p><p><ol><li>Run the binary in a Debugger (i.e. <strong>gdb ./BINARY</strong>)</li></ol></p><p><ol><li>Set a breakpoint at the vulnerable function (in this case it&#39;s <strong>gets()</strong>).</li></ol></p><p><ol><li>Input a Cyclic Pattern (e.g. 200 bytes). For example, you can generate this using the <a href="Misc_Attacks--Memory_Exploitation_75.html#pwntools Cyclic">Cyclic Module</a> from pwntools or with GDB&#39;s <strong>pattern create 200</strong>.</li></ol></p><p><ol><li>Let the program crash &amp; check the value of the Instruction Pointer (<strong>rip</strong> in 64-bit Arch). In this case, the value is <strong>0x6261616a</strong>.</li></ol></p><p><ol><li>Determine the exact offset where <strong>rip</strong> is overwritten. This can also be done with the <a href="Misc_Attacks--Memory_Exploitation_75.html#pwntools Cyclic">Cyclic Module</a> from pwntools using <strong>cyclic_find(0x6261616a)</strong>.</li></ol></p><p></p><p>The output shows that you have an offset of <strong>136</strong>. You know that the buffer is 128, &amp; 136-128=8. <strong>rbp</strong> is 8 bytes, so you know it&#39;s being used in this binary.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Checking File Type</span>: You can determine the Architecture used to compile a binary. If it&#39;s 64-Bit, you know it&#39;ll use <strong>rbp</strong> (8 bytes) IF the binary is using a Base Point Register. This doesn&#39;t check if a Base Point Register is being used at all.</p><p></p><p><em>file ./BINARY</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Using Decompiler</span>: Decompilers like Ghidra or IDA name variables based on offsets from <strong>rbp</strong>. See Ghidra <a href="Exploit_Research--Reverse_Engineering_31.html#Ghidra Naming Convention">naming convention</a> for more information.</p><p></p><p><h3>Putting It All Together</h3></p><p>The size of the Base Point Register is factored into the Debugger method &amp; the Decompiler method. The total size of your offset can be calcuated using the following formula (assuming the Base Point Register is being used).</p><p></p><p><strong>Offset = Buffer + Base Point Register</strong></p><p></p><p><h2>Redirecting Execution</h2></p><p>After your padding, overwrite the Return Address of the vulnerable function with the address of a target function.</p><p></p><p>In this case, you use <strong>136</strong> bytes /characters for the padding and then overwrite the Return Address for <strong>vuln()</strong> with the address of <strong>win()</strong> to trigger the <strong>system()</strong> function which will spawn a root shell.</p><p></p><p><strong>void </strong><strong><span style="color:#ff0000;">vuln</span></strong><strong>(void)</strong><strong></strong></p><p><strong>{</strong><strong></strong></p><p><strong>	char local_88[</strong><strong><span style="color:#ff0000;">128</span></strong><strong>];</strong><strong></strong></p><p><strong>	gets(local_88);</strong><strong></strong></p><p><strong>}</strong></p><p>...</p><p><strong>void </strong><strong><span style="color:#ff0000;">win</span></strong><strong>(void)</strong><strong></strong></p><p><strong>{</strong><strong></strong></p><p><strong>	fwrite(&quot;Congrats, you made it on the box&quot;, 1, 0x20, stdout);</strong><strong></strong></p><p><strong>	</strong><strong><span style="color:#ff0000;">system</span></strong><strong>(&quot;/bin/sh&quot;);</strong><strong></strong></p><p><strong>	return;</strong><strong></strong></p><p><strong>}</strong></p><p></p><p><a name="gdb target address"></a><h3>Determine Target Address</h3></p><p>Start the binary with GDB (may need to use <strong>chmod +x</strong> first), &amp; run the following commands within GDB. First, to make the binary easier to analyze, disable <a href="Defenses_+_Bypasses--Memory_Defenses_101.html#ASLR & DEP">ASLR</a> so memory addresses will stay consistent every time you run the program in GDB.</p><p></p><p>Next, prints the value of the symbol <strong>win </strong>with<strong> p win</strong> (aka <strong>print win</strong>) . If it&#39;s a function, GDB will print its memory address. If it&#39;s a variable, it prints its current value.</p><p></p><p>You can confirm this address by running <strong>info address win</strong>, which explicitly shows where <strong>win</strong> is stored in memory.</p><p></p><p><em>gdb ./BINARY</em></p><p></p><p><em>set disable-randomization on</em><em></em></p><p><em></em><em></em></p><p><em>p win</em></p><p></p><p><strong>$1 = {&lt;text function&gt;} </strong><strong><span style="color:#ff0000;">0x400646</span></strong><strong> &lt;win&gt;</strong></p><p></p><p><em>info address win</em></p><p></p><p><h2>Crafting Payload</h2></p><p>You may be able to remotely exploit the target by connecting via SSH using <a href="Misc_Attacks--Memory_Exploitation_75.html#pwntools remote BoF">pwntools</a> or <a href="Misc_Attacks--Memory_Exploitation_75.html#ropstar Remote BoF">ropstar</a>. Those methods will automatically execute the binary, trigger the BoF, &amp; give you the Reverse Shell.</p><p></p><p>However, if remote exploitation isn&#39;t possible, you can craft a payload file for local exploitation as shown below.</p><p></p><p><h3>Converting Target Address</h3></p><p>Most systems running 64-Bit binaries use <strong>Little-endian Byte Order</strong>, which stores the Least Significant Bit (LSB) first. The <span style="color:#ff0000;">Return Address</span> on the stack must <span style="color:#ff0000;">match the processor&#39;s endianness</span> (e.g. Little-endian).</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Generate Binary Payload</span>: You can use Python3 to create the payload. Your payload will be in <span style="color:#ff0000;">binary format</span> (non-printable characters), so you need to <span style="color:#ff0000;">write it to a file</span> that you&#39;ll upload to the target machine. See my <a href="https://github.com/Komodo-pty/ares-attack/blob/main/BoF_payload.py">Ares</a> tool suite.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: Python is smart enough that even if the user enters <strong>400646</strong> (without the <strong>0x</strong> prefix), <strong>int(&quot;400646&quot;, 16)</strong> still works just fine. Therefore, using base=16 makes your code handle both cases.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Manual Conversion</span>: It&#39;s easier to use the aforementioned script to convert the address into <strong>Little-endian Byte Order</strong>, but it&#39;s good to know how the conversion works.</p><p></p><p>Since <strong>Little-endian Byte Order</strong> stores the Least Significant Bit (LSB) first, the order of bytes (2 Hex digits) is reversed.</p><p></p><p>This is because in binary, the amount of data that can be stored by each bit increases exponentially. Therefore, the significance of each bit decreases &amp; the last bit is the LSB.</p><p></p><p>The <span style="color:#ff0000;">length of</span> a machine&#39;s memory <span style="color:#ff0000;">address varies based off</span> of its <span style="color:#ff0000;">architecture</span>. 2 Hex digits make up 1 byte.</p><p><ul><li>32-Bit: 4 bytes or 8 digits (e.g. 0x08048426)</li></ul></p><p><ul><li>64-Bit:	8 bytes or 16 digits (e.g. 0x7fffffffe1b0)</li></ul></p><p></p><p>In this case, the binary is 64-Bits, so the address <strong>0x400646</strong> should be 16 digits (8 bytes). This is an abbreviation, since the 0&#39;s prepended to a binary value are often omitted. The address is really <strong>0x0000000000400646</strong>.</p><p></p><p>Break the address up into chunks of bytes with a <strong>\x</strong> prefix &amp; reverse the order. The address converted to Little-endian Byte Order is <strong>\x46\x06\x40\x00\x00\x00\x00\x00</strong></p><p></p><p><h2>Exploitation</h2></p><p>It may take a little bit for your root shell to spawn, so commands may not work at first. Wait &amp; hit Enter a few times.</p><p></p><p><h3>Local Exploitation</h3></p><p>Upgrade / Stabilize the shell (preferably with SSH). Exploiting BoF can often crash you terminal session, so it&#39;s a good idea to have &gt;1 shell.</p><p></p><p>To <span style="color:#ff0000;">reduce the chance of the binary crashing</span>, you can use <strong>cat</strong> to <span style="color:#ff0000;">keep STDIO open</span>.</p><p></p><p><em>(cat payload.bin; cat) | ./BINARY</em></p><p></p><p><h3>Remote Exploitation</h3></p><p>If you can connect via SSH, the best options are either <a href="Misc_Attacks--Memory_Exploitation_75.html#pwntools remote BoF">pwntools</a> or <a href="Misc_Attacks--Memory_Exploitation_75.html#ropstar Remote BoF">ropstar</a>.</p><p></p><p>If the binary is running on a listening port, you may be able to pipe your payload directly into it.</p><p></p><p><em>(cat payload.bin; cat) | nc 172.0.0.1 4444</em></p><p></p><p><a name="Base Point Register"></a><h1>Base Point Register (rbp &amp; ebp)</h1></p><p><strong>rbp</strong> stands for Base Pointer Register in the x86-64 architecture (it’s called <strong>ebp</strong> in 32-bit x86). It’s one of the general-purpose registers in a CPU, and its primary role is to help manage the stack frame during function calls.</p><p></p><p>Think of it as a bookmark that keeps track of where a function’s stack frame begins, making it easier to access local variables and function parameters.</p><p></p><p><h2>How It Works</h2></p><p><ol><li>When a function is called, the CPU sets up a stack frame—a region of memory on the stack for the function’s local variables, saved registers, and return address.</li></ol></p><p><ol><li>The stack pointer (rsp in x86-64, esp in 32-bit) points to the top of the stack and moves as data is pushed or popped.</li></ol></p><p><ol><li>The base pointer (rbp) is typically set to the value of rsp at the start of the function, after reserving space for local variables. This creates a stable reference point, even as rsp changes during the function’s execution.</li></ol></p><p></p><p>For example, in assembly, a function prologue might look like this (x86-64):</p><p></p><p>{asm}</p><p></p><p><strong>push rbp </strong>         ; Save the caller&#39;s rbp on the stack</p><p><strong>mov rbp, rsp </strong>     ; Set rbp to the current stack pointer</p><p><strong>sub rsp, 0x80 </strong>    ; Allocate 128 bytes for local variables</p><p></p><p>    push rbp saves the caller’s rbp (so it can be restored later).</p><p>    mov rbp, rsp sets rbp to the current stack top.</p><p>    sub rsp, 0x80 moves rsp down to make room for variables (e.g., the 128-byte buffer in your vuln function).</p><p></p><p>Now, local variables can be accessed relative to rbp (e.g., [rbp - 0x88] for your local_88 buffer), and the return address is often at [rbp + 8] (after the saved rbp).</p><p></p><p>When the function ends, the epilogue restores everything:</p><p></p><p>{asm}</p><p></p><p><strong>mov rsp, rbp</strong>      ; Restore rsp</p><p><strong>pop rbp</strong>           ; Restore the caller&#39;s rbp</p><p><strong>ret</strong>               ; Return to the caller</p><p></p><p><h3>Base Point Register Size</h3></p><p>The size of the Base Point Register depends on the architecture.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">x86-64 (64-bit)</span>: <strong>rbp</strong> is 8 bytes (64 bits). This is because all general-purpose registers in 64-bit mode are 64 bits wide. When rbp is pushed onto the stack, it takes up 8 bytes, and the stack is aligned to 8-byte boundaries in 64-bit systems.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">x86 (32-bit)</span>: <strong>ebp</strong> (the 32-bit version) is 4 bytes (32 bits). The stack alignment is typically 4 bytes in 32-bit systems.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Other Architectures</span>: The size varies. For example, in ARM (64-bit AArch64), the equivalent frame pointer register (x29) is 64 bits (8 bytes), but in 32-bit ARM, it’s 32 bits (4 bytes).</p><p></p><p><h2>rbp Use Case</h2></p><p></p><p>Stability: rsp changes as you push/pop data, but rbp stays fixed, simplifying variable access.</p><p></p><p>Debugging: It helps debuggers and decompilers reconstruct the stack frame.</p><p></p><p>Convention: It’s part of the System V ABI (used by Linux and many UNIX-like systems) for x86-64, though it’s optional in some cases.</p><p></p><p><h3>Not Always Used!</h3></p><p>Optimization: Modern compilers (e.g., gcc with -O2 or higher) often omit the frame pointer (rbp) to free up a register and reduce instructions. In such cases, rsp is used directly, and there’s no “saved rbp” on the stack.</p><p></p><p>This is controlled by flags like<strong> -fomit-frame-pointer</strong>.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Example Binary</span></p><p></p><p>The decompiled code references <strong>local_88</strong>, &amp; the naming suggests rbp is used (decompilers like IDA or Ghidra name variables based on offsets from rbp). But if the binary was optimized, the offset to the return address might skip the 8-byte rbp slot.</p><p></p><p><h1>Instruction Pointer (rip &amp; eip)</h1></p><p><strong>rip</strong> refers to the Instruction Pointer register on x86-64 (<span style="color:#ff0000;">64-Bit</span>) processors. It stands for &quot;Register Instruction Pointer&quot;, and it&#39;s part of the CPU&#39;s architecture.</p><p></p><p>RIP holds the memory address of the next instruction the CPU will execute. It&#39;s critical for <span style="color:#ff0000;">program control flow</span>.</p><p></p><p><h2>Other Architectures</h2></p><p><h3>32-bit x86 (IA-32)</h3></p><p></p><p>    <strong>EIP</strong> = Extended Instruction Pointer</p><p></p><p>    Equivalent to RIP but for 32-bit systems.</p><p></p><p>    When the move to 64-bit happened, EIP became RIP (&quot;R&quot; stands for 64-bit register).</p><p></p><p><h3>ARM Architecture</h3></p><p>ARM doesn&#39;t use a register called RIP or EIP, but it still has an instruction pointer:</p><p></p><p>    <strong>PC</strong> = Program Counter</p><p></p><p>    Serves the same purpose as RIP/EIP.</p><p></p><p>    In ARMv7 (32-bit) and ARMv8 (64-bit), PC holds the address of the next instruction.</p><p>    </p><p>    </p><p><h2>Relevance</h2></p><p>Exploitation &amp; Hacking:</p><p>In many types of attacks—like buffer overflows—attackers try to control the RIP to redirect program execution to their own malicious code.</p><p></p><p>Return-Oriented Programming (ROP):</p><p>A common exploit method where attackers chain together bits of legitimate code (&quot;gadgets&quot;) by carefully setting the RIP to point to each one in turn.</p><p></p><p>Crash Analysis &amp; Debugging:</p><p>When analyzing a program crash or malware, security professionals often look at the value of RIP to understand what instruction was about to run or where things went wrong.</p><p></p><p><h2>RIP vs RBP</h2></p><p>In a typical function call, the stack looks like this:</p><p></p><p><strong>[ local variables ]</strong></p><p><strong>[ saved RBP ]  </strong>   							(RBP points here)</p><p><strong>[ return address ]</strong>  					(what RIP will become when function returns)</p><p></p><p>So in a buffer overflow, if you overflow past the local variables and overwrite:</p><p></p><p>    RBP — You mess up stack frame navigation.</p><p></p><p>    RIP (return address) — You gain control of where the program jumps next.</p><p></p><p><h3>RIP (Instruction Pointer)</h3></p><p></p><p>    Holds the address of the next instruction to execute.</p><p></p><p>    You don&#39;t typically manipulate it directly in code (except with jumps, calls, or returns).</p><p></p><p>    Attackers target RIP to change the flow of execution (e.g., redirecting to shellcode).</p><p></p><p><h3>RBP (Base Pointer)</h3></p><p></p><p>    Used to reference function stack frames.</p><p></p><p>    Points to the base of the current stack frame, making it easier to access local variables and function parameters.</p><p></p><p>    Helpful for stack unwinding and debugging.</p><p></p><p>    Attackers often overwrite RBP to mess with the stack layout or to get to RIP, especially in stack smashing.</p><p>    </p><p>    </p></div>
</body>
</html>
