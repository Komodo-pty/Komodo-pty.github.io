<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Appendix</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Appendix</h1><br/><p><h1>Decoding String</h1></p><p>There are common methods of encoding (e.g. UTF-8, Base64, ROT13, etc), but there are often <span style="color:#ff0000;">less common variants</span> that&#39;re typically <span style="color:#ff0000;">indicated via a different number</span> (e.g. UTF-16, Base32, ROT24)!</p><p></p><p>Exlcuding methods like ROT13 which can&#39;t encode non-readable characters, you probably <span style="color:#ff0000;">successfully decoded</span> a string if the <span style="color:#ff0000;">output doesn&#39;t have non-readable</span> characters.</p><p></p><p>There can be<span style="color:#ff0000;"> &gt;1 layer </span>of encoding applied to the string (e.g. 2x B64, ASCII → B64 → ROT13, etc)</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: Sometimes it&#39;s just is a garbled string that doesn&#39;t need decoding, &amp; that <span style="color:#ff0000;">string could still be a password</span>!</p><p></p><p><h2>Indicators</h2></p><p><h3>Uppercase &amp; Lowercase Letters</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">B64</span>: <span style="color:#ff0000;">Likely</span> to be B64 (or some variant of it), since Base64 is case-sensitive.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Hashes</span>: Hashes aren&#39;t case sensitive, so it&#39;s unlikely to be a hash (but still could be!).</p><p></p><p><h3>3 Digit Numbers</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">ASCII</span>: <span style="color:#ff0000;">Likely</span> to be ASCII using Octal Encoding, 1 of the methods used for ASCII conversion. Should be able to use normal <a href="https://www.duplichecker.com/ascii-to-text.php">ASCII to Text</a> decoder.</p><p></p><p><h3>Contains %</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">URL Encoding</span>: Very <span style="color:#ff0000;">Likely</span>. The most common method for URL Encoding utilizes numbers following a %. There are alt methods for Encoding (e.g. Burpsuite uses + instead of %20 by default).</p><p></p><p><h3>Contains =</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">B64</span>: Very <span style="color:#ff0000;">Likely</span> to be B64 (or some variant of it).</p><p></p><p><h3>Contains x Then Number</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">Hex</span>:  Very <span style="color:#ff0000;">Likely</span>. Hex can use other delimiters though (e.g. space, %, etc). See <a href="https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')">CyberChef</a> for other common delimiters.</p><p></p><p><h3>Alphanumeric (A-F) Chunks</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">Hex</span>:  Very <span style="color:#ff0000;">Likely</span>.</p><p></p><p><h2>Identify Hashes</h2></p><p>Hashes can look like an encoded string, so you should rule them out.</p><p></p><p><h3>Indicators</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">$ Sign</span>: Very <span style="color:#ff0000;">Likely</span> to be a salted hash.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Uppercase &amp; Lowercase Letters</span>: Hashes aren&#39;t case sensitive, so it&#39;s unlikely to be a hash (but still could be!).</p><p></p><p><h2>Serialized / Pickled Data</h2></p><p>[Portswigger 104-125]</p><p>Looks different for different programming languages. Identifying likely languages used by the host (e.g. host&#39;s Web App) can help narrow down possibilities, but it&#39;s still <span style="color:#ff0000;">possible for a server to contain data serialized using a different language</span>!</p><p></p><p>Serialized data is <span style="color:#ff0000;">commonly found in Web Apps</span> (especially in their <span style="color:#ff0000;">cookies</span>!).</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Non-Readable Characters</span>: Common for serialized data to contain a <span style="color:#ff0000;">mix of readable &amp; non-readable</span> characters.</p><p></p><p><h3>Python Pickling</h3></p><p>[CTF B 104]</p><p></p><p>There are different formats for Python Serialized Data which look different.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Example</span>: Often contains seperators like p1, p2, etc (I think?)</p><p></p><p>(dp0</p><p>Vusername</p><p>p1</p><p>Vadmin</p><p>p2</p><p>sV_permanent</p><p>p3</p><p>I01</p><p>s.</p><p></p><p><h3>PHP</h3></p><p>Contains colon seperated fields, sometimes with JSON mixed in.</p><p></p><p>Typically, the data type is 1st defined (O = Object, s = string, b = boolean).</p><p></p><p>Next the size of the data is listed (e.g. “User” is 4 characters, since quotes aren&#39;t included).</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Example</span></p><p>O:4:&quot;User&quot;:2:{s:4:&quot;name&quot;:s:3:&quot;bob&quot;; s:10:&quot;isLoggedin&quot;:b:1;}</p><p></p><p><h3>Java</h3></p><p>[Portswigger 107]</p><p></p><p>&quot;One of tha languages that uses a binary serialization format, which is hard to read, but you can identify serialized data by looking for tell-tale signs. For example,</p><p></p><p>Serialized Java objects <span style="color:#ff0000;">always being with the same bytes</span>, which are encoded as <strong>ac ed</strong> in Hex or <strong>ro0</strong> in Base64.&quot; -Portswigger (idk if always true)</p><p></p><p><h2>BrainFuck (esolang)</h2></p><p>Esoteric Languages, like BrainFuck, tend to have a very distinct syntax. For example, BrainFuck is a mixture of the following symbols &amp; can be <a href="https://www.dcode.fr/brainfuck-language">decoded using online tools</a>.</p><p></p><p><strong>+++++ ++++[ -&gt;+++ +++++ +&lt;]&gt;+ +++.&lt; +++++ [-&gt;++ +++&lt;] &gt;++++ +.&lt;++ +[-&gt;-</strong><strong></strong></p><p><strong>--&lt;]&gt; ----- .&lt;+++ [-&gt;++ +&lt;]&gt;+ +++.&lt; +++++ ++[-&gt; ----- --&lt;]&gt; ----- --.&lt;+</strong><strong></strong></p><p><strong>++++[ -&gt;--- --&lt;]&gt; -.&lt;++ +++++ +[-&gt;+ +++++ ++&lt;]&gt; +++++ .++++ +++.- --.&lt;+</strong><strong></strong></p><p><strong>+++++ +++[- &gt;---- ----- &lt;]&gt;-- ----- ----. ---.&lt; +++++ +++[- &gt;++++ ++++&lt;</strong><strong></strong></p><p><strong>]&gt;+++ +++.&lt; ++++[ -&gt;+++ +&lt;]&gt;+ .&lt;+++ +[-&gt;+ +++&lt;] &gt;++.. ++++. ----- ---.+</strong><strong></strong></p><p><strong>++.&lt;+ ++[-&gt; ---&lt;] &gt;---- -.&lt;++ ++++[ -&gt;--- ---&lt;] &gt;---- --.&lt;+ ++++[ -&gt;---</strong><strong></strong></p><p><strong>--&lt;]&gt; -.&lt;++ ++++[ -&gt;+++ +++&lt;] &gt;.&lt;++ +[-&gt;+ ++&lt;]&gt; +++++ +.&lt;++ +++[- &gt;++++</strong><strong></strong></p><p><strong>+&lt;]&gt;+ +++.&lt; +++++ +[-&gt;- ----- &lt;]&gt;-- ----- -.&lt;++ ++++[ -&gt;+++ +++&lt;] &gt;+.&lt;+</strong><strong></strong></p><p><strong>++++[ -&gt;--- --&lt;]&gt; ---.&lt; +++++ [-&gt;-- ---&lt;] &gt;---. &lt;++++ ++++[ -&gt;+++ +++++</strong><strong></strong></p><p><strong>&lt;]&gt;++ ++++. &lt;++++ +++[- &gt;---- ---&lt;] &gt;---- -.+++ +.&lt;++ +++++ [-&gt;++ +++++</strong><strong></strong></p><p><strong>&lt;]&gt;+. &lt;+++[ -&gt;--- &lt;]&gt;-- ---.- ----. &lt;</strong></p><p></p><p><a name="jwt"></a><h1>JWT (JSON Web Token)</h1></p><p>[Web App 62-63]</p><p></p><p>Very common for Serialized Cookies.</p><p></p><p>They consist of B64 encoded chunks seperated by a<strong> .</strong>, which you&#39;ll need to remove in order to properly B64 Decode them.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: You may be able to decode JWT, modify a value, &amp; re-encode it. However, sometimes, the JWT won&#39;t be valid &amp; you instead may need to exploit a <a href="Recon_+_Services--WebApp--Attack_Vectors_65.html#Mass Assignment">Mass Assignment vulnerability</a>.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">JWT.io</span>: Special made <a href="https://jwt.io/">website</a> for <span style="color:#ff0000;">decoding &amp; encoding</span> JWTs. </p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">CyberChef</span>: Try <strong>JWT Decode</strong> recipie. If that doesn&#39;t work, can try using its <strong>From Base64</strong> recipie which will remove characters it can&#39;t decode, leaving you with a clean-ish output.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Manually Decode Chunks</span>: Copy / Paste each chunk (before &amp; after the <strong>.</strong> ) into an Online <a href="https://www.base64decode.org/">B64 Decoder</a>. Seems reliable, but CyberChef is my 1st choice.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">CLi</span>: In the following example, the IFS is set to<strong> .</strong> so they&#39;ll be treated as a space. Worked for guy using it, but <span style="color:#ff0000;">didn&#39;t work for me</span> (even though I copy / pasted it).</p><p></p><p>export IFS=&quot;.&quot;;jwt=&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc0FkbWluIjp0cnVlLCJfaWQiOiI1ZWM2ZTVjZjFkYzRkMzY0YmY4NjQxMDciLCJ1c2VybmFtZSI6ImRhdmUiLCJwYXNzd29yZCI6IlRITXtTdXBlclNlY3VyZUFkbWluUGFzc3dvcmQxMjN9IiwiX192IjowLCJpYXQiOjE2MDA4NDQ3MDR9.nioG_MjIcRGJ3PObm0QcDv_eIqRU6baBCYAi7aRWVPw&quot;;for j in $jwt; do echo &quot;$j&quot; | base64 -d;done</p><p></p><p><a name="Steganography"></a><h1>Steganography</h1></p><p>See <a href="https://book.hacktricks.xyz/crypto-and-stego/stego-tricks">Hacktricks</a>. There is also Audo Steganography.</p><p></p><p>Fetch the image file with a tool like <strong>wget</strong> or <strong>curl</strong> to ensure that it isn&#39;t altered.</p><p></p><p><h2>Tools</h2></p><p>Use <strong>stegseek</strong> when possible, due to its speed.</p><p></p><p><strong>zsteg</strong>: PNG &amp; BMP</p><p></p><p><strong>stegseek</strong>: Improved steghide with added Brute-Forcing functionality! (Does it only support JPG? Or below filetypes too?). For full help menu, run <strong>stegseek --help -v</strong></p><p></p><p><strong>steghide</strong>: JPEG, BMP, WAV, &amp; AU</p><p></p><p><h2>Test for Steganography</h2></p><p><strong>stegseek --seed</strong> can tell you information about the file (e.g. if it likely contains steganograpgy, how much information is stored inside the steg, etc).</p><p></p><p><em>stegseek --seed 001-key.jpg</em></p><p></p><p><strong>[i] Found (possible) seed: &quot;3b75655e&quot;            </strong><strong></strong></p><p><strong>	Plain size: 47.0 Byte(s) (compressed)</strong><strong></strong></p><p><strong>	Encryption Algorithm: rijndael-128</strong><strong></strong></p><p><strong>	Encryption Mode:      cbc</strong></p><p></p><p><h2>Brute Force Password</h2></p><p>stegseek can BF rockyou.txt in seconds, so you might as well try every password wordlist.</p><p></p><p><em>for i in $(ls /usr/share/seclists/Passwords/Leaked-Databases/);do stegseek --crack -sf owl.jpg -wl /usr/share/seclists/Passwords/Leaked-Databases/$i;done</em></p><p></p><p><em>stegseek --crack -sf ant.jpg -wl list.txt</em></p><p></p><p><h2>Extract Using Known Password</h2></p><p><em>stegseek --extract -sf 002-key.jpg -p cGxhbnQ0Ml9jYW</em></p></div>
</body>
</html>
