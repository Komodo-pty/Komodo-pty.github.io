<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>ACL + ACE</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>ACL + ACE</h1><br/><p><a name="ACL"></a><h1>Background</h1></p><p>[Win 61-68]</p><p></p><p>See <a href="PrivEsc--Windows--Active_Directory_10.html#Abusing ACLs">Abusing ACLs</a></p><p></p><p><h2>ACL (Access Control List)</h2></p><p></p><p>An ACL is a list attached to an object (like a file, folder, AD user, or group) that defines who can do what with that object. ACLs can be configured locally, or in an Active Directory environment. ACLs <span style="color:#ff0000;">control both access &amp; auditing</span>.</p><p></p><p>There are two main types of ACLs:</p><p><ol><li><strong>DACL</strong> (Discretionary Access Control List)</li></ol></p><p><ol><li><strong>SACL</strong> (System Access Control List): Used for auditing</li></ol></p><p></p><p><strong>Object (e.g., User, File, Computer)</strong><strong></strong></p><p><strong>│</strong><strong></strong></p><p><strong>└── Security Descriptor</strong><strong></strong></p><p><strong>     │</strong><strong></strong></p><p><strong>     ├── Owner</strong><strong></strong></p><p><strong>     ├── Group</strong><strong></strong></p><p><strong>     ├── DACL (who can access)</strong><strong></strong></p><p><strong>     │    ├── ACE 1: Allow ryan Read</strong><strong></strong></p><p><strong>     │    ├── ACE 2: Allow ryan Write</strong><strong></strong></p><p><strong>     │    └── ACE 3: Deny guest All</strong><strong></strong></p><p><strong>     └── SACL (who gets audited/logged)</strong></p><p></p><p><h3>DACL (Discretionary Access Control List)</h3></p><p>This is the part of the security descriptor that defines permissions (i.e. which users or groups are allowed or denied access to the object).</p><p></p><p>If the DACL is missing or empty, then no one gets access (not even SYSTEM). A DACL is made up of a list of ACEs (allow / deny) &amp; <span style="color:#ff0000;">controls who has permissions</span>.</p><p></p><p><h3>SACL (System Access Control List)</h3></p><p>A SACL defines what kinds of actions trigger audit logs, like:</p><p></p><p>    &quot;Log when someone reads this file&quot;</p><p></p><p>    &quot;Log when someone tries to write to this user object&quot;</p><p></p><p>    &quot;Log failed delete attempts&quot;</p><p></p><p>It&#39;s part of an object&#39;s security descriptor, along with:</p><p></p><p>    Owner</p><p></p><p>    DACL</p><p></p><p>    Group</p><p></p><p>    SACL </p><p></p><p><h3>ACE (Access Control Entry)</h3></p><p>An ACE is a <span style="color:#ff0000;">single, specific permission rule</span> inside an ACL. Their purpose &amp; structure varies depending on whether or not they&#39;re inside of a DACL or SACL.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Inside DACL</span>: Grants or denies rights to a specific user, group, or SID. <span style="color:#ff0000;">Access ACEs</span></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Inside SACL</span>: Controls what actions get audited. <span style="color:#ff0000;">Audit ACEs</span>. For example, &quot;Generate an audit event if any user fails to write a property on this object.&quot;</p><p></p><p>[ACE] Audit Everyone - Failed access - WriteProperty</p><p></p><p><a name="Important ACLs"></a><h2>Important Permissions</h2></p><p>[Win 67]</p><p></p><p><h3>WriteOwner</h3></p><p>The <strong>WriteOwner</strong> permission allows a user to change the ownership of an Active Directory object. Ownership in AD grants a user implicit rights over the object, including the ability to change its permissions (DACL - Discretionary Access Control List).</p><p></p><p>Just because you have the <strong>WriteOwner</strong> permission doesn&#39;t mean you&#39;re the owner of that object, it just means that you can make youself the owner.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Uses</span>: By making yourself the owner of an object (e.g. a user or group), you can grant yourself the <strong>GenericAll</strong> permission (Full Control). See <a href="PrivEsc--Windows--Active_Directory_10.html#Abusing WriteOwner">Abusing WriteOwner</a>.</p><p><ol><li><strong>Privilege Escalation</strong></li></ol></p><p></p><p>A user with WriteOwner on an object (like a user or group) <span style="color:#ff0000;">can make themselves the owner</span>. Once they are the owner, they <span style="color:#ff0000;">can change the ACL</span> (permissions) to <span style="color:#ff0000;">give themselves Full Control</span>, even if they didn’t previously have it.</p><p><ol><li><strong>Lateral Movement</strong></li></ol></p><p></p><p> If granted on security groups or organizational units (OUs), an attacker can: Change ownership of those objects, Add themselves to privileged groups (like Domain Admins), Control users and computers within the OU.</p><p><ol><li><strong>Persistence</strong></li></ol></p><p></p><p>An attacker can make themselves owner and modify permissions to retain access even after remediation efforts. They can also <span style="color:#ff0000;">hide backdoors or schedule scripts via object attributes</span>.</p><p><ol><li><strong>Security Misconfiguration</strong></li></ol></p><p></p><p>Accidentally granting WriteOwner (especially via inheritance or delegation) can give regular users high-level control. Common misconfigurations include applying it to OUs, Group Policy Objects, or Service Accounts.</p><p><ol><li><strong>Bypassing Auditing/Monitoring</strong></li></ol></p><p></p><p>Changes made by the owner can bypass standard permission controls or be harder to detect if logs are not properly configured.</p><p></p><p><a name="ACLs in AD"></a><h1>ACLs in Active Directory</h1><span style="color:#ffbe6f;"></span></p><p><span style="color:#ffbe6f;"></span>You can <span style="color:#ff0000;">interact with ACLs locally </span>(e.g. via Powershell) using <span style="color:#ff0000;">Windows APIs</span>, or <span style="color:#ff0000;">remotely</span> through <span style="color:#ff0000;">direct LDAP manipulation</span>.</p><p></p><p>Although you can technically use Windows APIs and direct LDAP manipulation to do the same thing, <span style="color:#ff0000;">direct LDAP manipulation is a more reliable method</span> (e.g. Using Impacket).</p><p></p><p>Running Impacket-based commands remotely may work even when local PowerShell-based methods fail because of the API Layer Differences.</p><p></p><p><h2>API Layer Differences</h2></p><p>I believe it comes down to a discrepency in the permissions given to a user at the Domain level (in Active Directory) &amp; those assigned Locally (on the target machine itself).</p><p></p><p>If you have the permissions to do something in Active Directory, but are trying to perform those actions Locally (e.g. using Powershell), then the Local policies will supercede the Domain level permissions.</p><p></p><p>However, Impacket tools work where PowerShell fails because they skip Windows API enforcement and hit the domain controller directly via raw LDAP.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: You can replicate the Impacket behavior using low-level LDAP calls in PowerShell (e.g., using System.DirectoryServices.Protocols), but that&#39;s often an unneccesary amount of work.</p><p></p><p><h3>Windows PowerShell (ADSI/.NET)</h3><ul><li>Uses high-level Windows APIs (ADSI, DirectoryServices, etc.)</li></ul></p><p><ul><li>Enforces local security policies, ownership checks, and ACL enforcement at multiple layers</li></ul></p><p><ul><li>Often blocked by <strong>AdminSDHolder</strong>, protected object flags, or lack of <strong>WriteDACL</strong> permission — <span style="color:#ff0000;">even if you have </span><strong><span style="color:#ff0000;">GenericOwner</span></strong></li></ul></p><p></p><p><h3>Impacket (Linux tools)</h3><ul><li>Talks to Active Directory directly over LDAP (raw protocol level)</li></ul></p><p><ul><li>Bypasses local Windows policy enforcement</li></ul></p><p><ul><li>Only relies on what the DC allows, not what your local OS enforces</li></ul></p><p><ul><li>Tools like <strong>impacket-owneredit</strong> and <strong>impacket-dacledit</strong> implement LDAP Modify operations that go straight to the domain controller</li></ul></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Requirements</span>: Impacket should work as long as you meet the following 2 requirements, making it effective in low-privilege environments. Unless you&#39;re trying to be stealthy, there aren&#39;t really any reason to not use Impacket.</p><p><ol><li>The domain controller allows LDAP/SMB access.</li></ol></p><p><ol><li>The account has sufficient rights on the object being modified (like WriteOwner).</li></ol></p><p></p><p><h3>Why Impacket Commands Worked</h3></p><p>Impacket won&#39;t Enfore Local Windows Policies because it&#39;s talking to the DC directly.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">impacket-owneredit</span>: This sends a raw LDAP modify request to set the nTSecurityDescriptor&#39;s Owner field. As long as your account has <strong>WriteOwner</strong> or <strong>GenericOwner</strong>, the DC will allow it, even though Windows PowerShell may not.</p><p></p><p>The following command uses <strong>impacket-owneredit</strong> to change the ownership of the &quot;ca_svc&quot; account to “ryan” since ryan had <strong>WriteOwner</strong> permissions.</p><p></p><p><em>impacket-owneredit -action write -new-owner &#39;ryan&#39; -target &#39;ca_svc&#39; sequel.htb/ryan:password</em></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">impacket-dacledit</span>: This directly injects an ACE (Access Control Entry) into the nTSecurityDescriptor of ca_svc. You don’t need to be the owner locally or use <strong>Set-Acl</strong>, which is subject to .NET’s object model and security checks.</p><p></p><p>After the previous command gave ryan ownership over ca_svc, you can then use <strong>impacket-dacledit</strong> to grant ryan full control over that account (<strong>GenericAll</strong> permissions).</p><p>    </p><p><em>impacket-dacledit -action write -rights &#39;FullControl&#39; -principal &#39;ryan&#39; -target &#39;ca_svc&#39; sequel.htb/ryan:password</em></p><p></p><p><h3>Why PowerShell Methods Failed</h3></p><p>PowerShell uses the ADSI COM interface, which respects Windows&#39; local ACL evaluation rules, meaning:</p><p><ul><li>If you&#39;re not already the owner, you can&#39;t change the DACL.</li></ul></p><p><ul><li>If you don’t have WriteDACL, it blocks you before the request even hits the domain controller.</li></ul></p><p></p><p>Even if you had the right at the domain level, PowerShell wouldn&#39;t let you try.</p><p></p><p><h1>Filesystem ACLs</h1></p><p>Even if you are<span style="color:#ff0000;"> blocked from listing a directory</span>, you <span style="color:#ff0000;">may still be able to view a file </span>inside it by invoking it&#39;s absolute path (&amp; the same applies to other actions).</p><p></p><p><h2>View ACL</h2></p><p>[CTF B 146-147]</p><p></p><p>Run the following commands, &amp; then run the follow up commands to get a full picture. They both reveal different pieces of information. I&#39;m using <strong>FL</strong> (Format-List) to prevent cut-off output.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: You may need elevated privileges to even view the ACL!</p><p></p><p><em>get-acl C:\users\SuperAdmin\ | FL</em></p><p></p><p><em>icacls C:\Users\SuperAdmin\</em></p><p></p><p><h3>Additional Details</h3></p><p><em>$Acl = Get-Acl &quot;C:\users\SuperAdmin\&quot;</em></p><p><em>$Acl.Access</em></p><p></p><p><h2>Add New ACE</h2></p><p>I was having issues regarding inheritence, so you may / may not have to re-run this for children directories (Idk).</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: May have to specify <span style="color:#ff0000;">DOMAIN\USER</span>, even though I didn&#39;t have to here.</p><p></p><p><em>$Acl = Get-Acl &quot;C:\Users\SuperAdmin\&quot;</em><em></em></p><p><em>$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule(&quot;dave2&quot;, &quot;FullControl&quot;, &quot;Allow&quot;)</em><em></em></p><p><em>$Acl.SetAccessRule($Ar)</em><em></em></p><p><em>Set-Acl -Path &quot;C:\Users\SuperAdmin\&quot; -AclObject $Acl</em></p><p></p><p><h3>Alternative Command</h3></p><p>This should do the same thing, in addition to explicitly specifying inheritence. One method may work better than the other.</p><p></p><p><em>icacls C:\Users\SuperAdmin\ /grant &#39;dave2:(OI)(CI)(F)&#39;</em></p><p></p><p><h3>Troubleshooting</h3></p><p><span style="color:#8ff0a4;text-decoration:underline;">Can Create but not Remove</span>: I was able to create ACEs, but couldn&#39;t remove any existing ACEs. I have several theories as to why:</p><p></p><p>A) Maybe the ACE I wanted to remove was inherited, &amp; I&#39;d have to remove the inhertience property before removing the ACE.</p><p></p><p>B) Maybe my command syntax was wrong. (I tried multiple commands from StackOverflow, so I&#39;d expect them to work)</p><p></p><p>C) Maybe the UAC Intergrity Level was high enough to add an ACE, but not high enough to remove an ACE (unlikely, I assume there&#39;d be the same requirements?)</p><p></p><p><span style="color:#ff0000;">Workaround</span>: Created a new user, put them in RDP group to sign in remotely, &amp; I created an ACE to give them access.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Conflicting ACEs</span>: Created an ACE for “Full Access: Allow” when another ACE said “Full Access: Deny” &amp; my ACE wasn&#39;t taking effect. You need to remove the conflicting ACE, or create an account &amp; set the desired ACE for them.</p></div>
</body>
</html>
