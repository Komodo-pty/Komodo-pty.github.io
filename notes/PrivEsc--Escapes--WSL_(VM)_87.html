<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>WSL (VM)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>WSL (VM)</h1><br/><p>See <a href="https://exploit-notes.hdks.org/exploit/windows/wsl/wsl-pentesting/">Exploit-Notes</a></p><p></p><p><h1>Background</h1></p><p>Windows Subsystem for Linux (<a href="https://learn.microsoft.com/en-us/windows/wsl/about">WSL</a>) is like a Linux VM that&#39;s run on a Windows host.</p><p></p><p>Therefore, if inital Recon (e.g. Nmap) identifies a Windows machine, but you get a Linux shell on the target, you&#39;re probably inside a WSL VM.</p><p></p><p><h1>Accessing Host File System</h1></p><p>You can access the Windows host&#39;s FS, but you may need to be the root user inside the WSL VM. If you have enough privs, you can interact with <strong>Administrator</strong> files.</p><p></p><p>Identify where the host&#39;s drive is mounted (by default, Windows uses <strong>C:</strong> which translates to <strong>/mnt/c</strong>). If it&#39;s empty, you may need to mount it first.</p><p></p><p><em>ls -la /mnt/c</em></p><p></p><p><h2>Mounting Host File System</h2></p><p><em>mount -t drvfs C: /mnt/c</em></p><p></p><p><h1>Escaping WSL</h1></p><p>[CTF D 18-19]</p><p></p><p>You should be able to use <a href="https://learn.microsoft.com/en-us/windows/wsl/filesystems#run-windows-tools-from-linux">Windows Executables</a> from inside the WSL bash interface. I&#39;ve encountered some issues doing this though. If <strong>pwsh</strong> is installed on the Linux machine, you can also try using that.</p><p></p><p>You may / may not need to specify the file path to the Windows executable that you&#39;re trying to run (i.e. <strong>/mnt/c/Windows/System32/cmd.exe</strong> or <strong>/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe</strong>)</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: IME you have the highest chance of success if you use a malicious EXE, instead of using other file types.</p><p></p><p><h2>Leveraging Host File System</h2></p><p>Exfiltrating sensitive files was the most reliable method. I had issues leveraging malicious binaries (just an issue with the CTF?).</p><p></p><p><h3>Write Permissions</h3></p><p>Poison a file (Service&#39;s EXE, DLL Hijacking, etc)</p><p></p><p><h3>Read Permissions</h3></p><p>Look for Sensitive Files (SSH Private Keys, Hardcoded Creds, etc)</p><p></p><p><h2>Create a Scheduled Task</h2></p><p>1 method is to create scheduled tasks that&#39;d run on the Windows machine &amp; trigger a payload.</p><p></p><p><h3>Using pwsh</h3></p><p></p><p><span style="color:#237522;">Using Windows Executables</span></p><p>cmd.exe /c schtasks /create /tn &quot;BackupScript&quot; /tr &quot;C:\Users\Public\evil.exe&quot; /sc minute /mo 1</p><p></p><p>/mnt/c/Windows/System32/cmd.exe /c schtasks /create /tn &quot;BackupScript&quot; /tr &quot;powershell.exe -ExecutionPolicy Bypass -File C:\Users\Public\evil.ps1&quot; /sc minute /mo 1</p><p></p><p></p><p><h2>Create a Service</h2></p><p>Create a Windows Service which will run a malicious EXE file (using the absolute path) on the Host machine.</p><p></p><p><em>cmd /c “sc create PrivSvc binPath=C:\Users\Administrator\Documents\shell.exe”</em><em></em></p><p><em>cmd /c “sc start PrivSvc”</em></p><p></p></div>
</body>
</html>
