<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Reverse Engineering</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Reverse Engineering</h1><br/><p><h1>Binary Analysis</h1></p><p>[OSCP 192-193]</p><p>3 categories of methods: Extract human readable text, Decompile (Ghidra), Behavior Analysis. Linpeas may also attempt to do rudimentary analysis (e.g may be able to find a binary invoked via relative path)</p><p></p><p><h2>Pros &amp; Cons</h2><span style="color:#663e0e;"></span></p><p><span style="color:#663e0e;"></span>Extracting Human Readable text (e.g via <strong>strings</strong>) is fast &amp; grep-able, but least thorough.</p><p></p><p>Decompiling (e.g <strong>ghidra</strong>) can be time consuming &amp; only attempts static analysis.</p><p></p><p>Behavior Analysis (e.g <strong>ltrace</strong> or <strong>strace</strong>) will miss a lot of static code, but shows what the code is doing (dynamic analysis).</p><p></p><p>Best practice is to <span style="color:#ff0000;">combine Decompiling with Behavior Analysis</span>.</p><p></p><p><span style="color:#f66151;text-decoration:underline;">IMPORTANT</span>: Decompilers may miss things that can be found with Behavior Analysis (e.g. <strong>lrace</strong>)</p><p></p><p><h2>Chat-GPT</h2></p><p><span style="color:#f66151;text-decoration:underline;">NOT ON OSCP</span></p><p></p><p>Paste decompiled code into an AI tool like <a href="https://chatgpt.com/">Chat-GPT</a> to rapidly analyze hundreds of lines of code.</p><p></p><p>It can provide a simplified explanation &amp; will attempt to de-obfuscate it!</p><p></p><p>As an automated tool, it <span style="color:#ff0000;">sometimes</span> provides an <span style="color:#ff0000;">inaccurate analysis</span>!</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Adding New Lines</span>: Use <strong>Shift</strong>+<strong>Enter</strong> to go down a line without submitting the query.</p><p></p><p>For example, <strong>Analyze the following code</strong> (Shift+Enter) CODE. Another query could be, <strong>Why is this code vulnerable</strong> &lt;to privilege escalation&gt;</p><p></p><p><h3>Bypassing Filters</h3></p><p>Chat-GPT has guidelines regarding immoral activities, like hacking. If you trip a filter, the Chat-GPT response will be automatically deleted.</p><p></p><p>You have to word your queries precisely to avoid the filters, or use special syntax to bypass them.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Avoid Filters</span>: Security Research &amp; Defensive activities aren&#39;t malicious, but can be easily confused with Black Hat activities.</p><p></p><p>For example, if you ask <strong>how</strong> to exploit a binary, your msg is more likely to be flagged than if you asked <strong>why</strong> is this binary vulnerable. It still may tell you how to exploit it anyways.</p><p></p><p>Sometimes it can also help to provide context like, <strong>As a security researcher</strong>...</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Bypass Filters</span>: These methods will likely need to be continually modified as they&#39;re patched, but there are example queries for jailbreaking Chat-GPT (e.g. on Github or StackOverflow). For ex, create multiple personalities.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Using Burpsuite?</span>: Since there&#39;s currently a small delay between it responding &amp; that msg being deleted, maybe you could toggle on Burp&#39;s Interceptor before submitting query &amp; <strong>Intercept Response</strong> to the Request.</p><p></p><p>You may not be able to get the full response, but maybe this could let you view at least part of that msg?</p><p></p><p><h1>Online Decompiler</h1></p><p><a href="https://dogbolt.org/">dogbolt</a> lets you upload a file &amp; it attempts to decompile it using a variety of different tools.</p><p></p><p>Gave me more results than when I ran Ghidra manually, &amp; makes output easier to read &amp; copy/paste into Chat-GPT.</p><p></p><p><h1>Ghidra</h1></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: Got better results using Online Decompiler (which utilized Ghidra). Maybe I wasn&#39;t using Ghidra as well as I could&#39;ve been, but try the aforementioned website.</p><p></p><p>In <strong>Code Browser</strong>, the middle pane is called <strong>Listing</strong> &amp; the R pane is <strong>Decompiler</strong></p><p><span style="color:#663e0e;"></span></p><p><span style="color:#663e0e;"></span><h2>Setup</h2></p><p>Specify where to store the Ghidra files &amp; then import the binary</p><p></p><p><strong>File </strong>→ <strong>New Project</strong><strong></strong></p><p><strong>File  </strong>→<strong> Import  File </strong>→<strong> </strong>BINARY</p><p>2x Click Binary File to open <strong>Code Browser</strong> (Dragon icon) on it </p><p></p><p>Use def settings for Ghidra to auto-analyze the binary. If needed, can re-analyze later with more in detail settings, but some non-def opts could cause issues.</p><p></p><p><h2>Viewing Code</h2></p><p>Ghidra tries to break the code into sections (e.g for functions which it deliniates via a box of ***).</p><p><span style="color:#ff0000;">Click on each section of code</span> in the <strong>Listing</strong> pane to view that section in the <strong>Decompiler</strong> pane.</p><p></p><p><h3>Bookmarks</h3></p><p>R click a line of code in <strong>Listing</strong> and <span style="text-decoration:underline;">Bookmark</span> causing a<span style="color:#613583;"> </span><span style="color:#813d9c;">✔</span> to appear on the L side bar</p><p></p><p>Click the <span style="color:#813d9c;">✔</span> in the Top Menu bar to display all bookmarks (or Ctrl + B)</p><p></p><p><a name="Ghidra Naming Convention"></a><h2>Variable Naming Convention</h2></p><p>I believe that a variable name containing <strong>local</strong> indicates that it&#39;s a Local Variable as opposed to a Global Variable.</p><p></p><p>Decompilers like Ghidra or IDA name variables based on offsets from <strong>rbp</strong> &amp; represent this offset in Hex.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: I think Ghidra will try to differentiate between <strong>rbp</strong> &amp; <strong>ebp</strong>, but I don&#39;t think it can tell whether or not the binary was optimized to use a <a href="Misc_Attacks--Memory_Exploitation--Background_93.html#Base Point Register">Base Point Register</a> (just assumes it&#39;s in use). Using a Debugger is the most reliable way to determine the Offset for a BoF.</p><p></p><p><h3>Example</h3></p><p>In this case there&#39;s a variable named <strong>local_88</strong> &amp; it has a buffer of <strong>128</strong> bytes. This suggests that the buffer is at the offset <strong>0x88</strong> in Hex, or <strong>136</strong> when translated to decimal. You know the buffer is 128 bytes, so</p><p></p><p>136 - 128 = 8 = rbp (64-Bit)</p><p></p><p><strong>void vuln(void)</strong><strong></strong></p><p><strong>{</strong><strong></strong></p><p><strong>	char </strong><strong><span style="color:#ff0000;">local_88</span></strong><strong>[</strong><strong><span style="color:#ff0000;">128</span></strong><strong>];</strong><strong></strong></p><p><strong>	gets(local_88);</strong><strong></strong></p><p><strong>}</strong></p><p></p><p>The name of the variable would change if the buffer was a different size. For instance, if the buffer was 256 bytes + 8 byte <strong>rbp</strong>, the name would be <strong>local_108</strong> (264 bytes total).</p><p></p><p><h1>Radare2 (r2)</h1></p><p>[CTF-2 122]</p><p><a href="https://rada.re/n/radare2.html">Radare2</a> is a toolchain for performing low level tasks like forensics, software reverse engineering, exploiting, debugging, etc.</p><p></p><p>Can <span style="color:#ff0000;">catch things missed by Ghidra</span> (could just be because I&#39;m running r2 on target &amp; Ghidra on file exported to my machine, or because I&#39;m not fully utilizing Ghidra)</p><p></p><p><h2>Setup</h2></p><p><em>r2 /PATH/binary</em></p><p></p><p><h3>Start Full Analysis</h3></p><p>After starting r2, run the following to analyze the binary before performing any additional actions</p><p></p><p><em>aaa</em></p><p></p><p><h2>Analyze Functions</h2></p><p>Output functions in verbose mode in a colored &amp; easy to understand table with <strong>afll</strong>. For this example, it lists a function called <strong>sys.call_bash</strong>; select it for further analysis using <strong>s</strong> &amp; disassemble with <strong>pdf</strong>.</p><p></p><p><em>afll</em></p><p><em>s sym.call_bash</em><em></em></p><p><em>pdf</em></p><p></p><p><h1>Behavior Analysis</h1></p><p><span style="color:#ff0000;">MUST perform EVERY action</span> that the program can perform to get a full picture (i.e if there is an options menu, try every opt)</p><p></p><p><h2>pspy</h2></p><p>Run in 1 terminal &amp; then run the binary in another</p><p></p><p><h2>strace</h2></p><p></p><p><h2>ltrace</h2></p><p><em>ltrace /usr/bin/binary</em></p><p></p><p><h3>Detecting User Input</h3></p><p>For example, the binary prompts for user input right after <strong>ltrace</strong> outputs a reference to the string “warzoneinadana”. </p><p></p><p>Supply that string as the user input to trigger the target function. (Decompilers didn&#39;t detect this string!)</p></div>
</body>
</html>
