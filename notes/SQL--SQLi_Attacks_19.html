<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>SQLi Attacks</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>SQLi Attacks</h1><br/><p>[PortSwigger 58-79, OSCP]</p><p></p><p><h1>Attack Vectors</h1></p><p>[OSCP 66, CTF D 1-8]</p><p></p><p><h2>RCE</h2></p><p><h3>Web Shell</h3></p><p>May be able to use SQLi to write code to a file (or a row of data?) that <a href="Recon_+_Services--WebApp_12.html">WebApp</a> will process, triggering RCE.</p><p></p><p>If writing a Web App backdoor file, need to know the Web Root directory. You can find it by triggering an SQL Error, or you can guess common locations (e.g. <strong>/var/www/html/</strong> ).</p><p></p><p><h3>SSH</h3></p><p>If you can Read the host&#39;s filesystem, you may be able to find SSH Keys.</p><p></p><p>If you can Write in a user&#39;s home directory, you may be able to upload your public SSH Key to <strong>authorized_keys</strong>.</p><p></p><p><h3>DMBS Specific Methods</h3></p><p>Many kinds of SQL DBMS have a unique mechanism(s) to get RCE directly, without needing to upload a backdoor to a Web App. See the corresponding section for more info. For example,</p><p></p><p>MSSQL has <strong>xp_cmdshell</strong> built-in, but it may need to be enabled (which requires certain privs).</p><p></p><p><h2>Sensitive Info</h2></p><p>Check current DB, &amp; other DBs for sensitive info (e.g. credentials). A built-in schema may contain password hashes for the SQL Login (which may differ from the Web App credentials stored in another DB).</p><p></p><p>Even if you can&#39;t find creds (or crack passwd hash), you may find other useful info (e.g. usernames, emails, etc).</p><p></p><p><h3>Credential Reuse</h3></p><p>If you can leverage SQLi to steal credentials, you may be able to find other users &amp;/or services which also use those same creds.</p><p></p><p><h3>Extract Current Queries (Clear-Text Creds)</h3></p><p>Depending on the DBMS, you may be able to extract the currently running queries from a built-in schema. See <a href="SQL--DBMS--MySQL_+_MariaDB_17.html#Extract Current Queries">MySQL + MariaDB</a></p><p></p><p>Depending on the hashing implementation, this may mean that you can <span style="color:#ff0000;">sniff the login attempts</span> from all users <span style="color:#ff0000;">before the password is hashed</span>!</p><p></p><p><h2>Web App Authentication</h2><span style="color:#663e0e;"></span></p><p><span style="color:#663e0e;"></span>SQLi may let you change a user&#39;s Web App permissions, granting you Admin access.</p><p></p><p><h3>Bypass Login</h3></p><p>SQLi is a common vector for Web App <a href="SQL--SQLi_Attacks_19.html#Login Bypass">Login Bypasses</a>. It typically is used to authenticate without a password, but sometimes you can sign in without a username also.</p><p></p><p><h3>Steal Credentials</h3></p><p></p><p><h3>Create New User</h3></p><p></p><p><h3>Modify User&#39;s Password</h3><span style="color:#663e0e;"></span></p><p><span style="color:#663e0e;"></span>Ideally, you should <span style="color:#ff0000;">copy the uer&#39;s current passwd</span> before trying to change it. In case there is credential reuse, you don&#39;t want to permanently overwrite any passwds.</p><p></p><p><h2>File System Interaction</h2></p><p>When leveraging SQLi, the queries are being run in the context of a user account. Therefore, you may be limited by the privileges that this user has.</p><p></p><p><h3>File Write</h3></p><p>SSH Key, backdoor</p><p></p><p><h3>File Read</h3></p><p>SSH Key, source code, etc.</p><p></p><p>Try to recover <span style="color:#ff0000;">source code</span>, <span style="color:#ff0000;">hard-coded creds</span>, etc.</p><p></p><p><h1>Retrieving Hidden Data</h1></p><p></p><p><a name="Login Bypass"></a><h1>Subverting Application Logic (Login Bypass)</h1></p><p>SQL is almost always used to authenticate user:passwd, especially for larger Apps. For example, credentials may be checked by substituting user input into a query like so-</p><p></p><p><strong>SELECT * FROM users WHERE username = ‘</strong><em>bob</em><strong>’ AND password = ‘</strong><em>secret</em><strong>’;</strong></p><p></p><p><span style="color:#060f94;text-decoration:underline;">Tip</span>: May be able to leave password blank, but <span style="color:#ff0000;">often need to use an arbitrary string for the password</span> instead.</p><p></p><p><h2>★</h2><h2> </h2><h2>LIMIT Rows Returned</h2> <h2>★</h2></p><p>See this <a href="https://www.youtube.com/watch?v=8iSGWP7lk-M">video</a> made by Tiberious.</p><p></p><p>The standard <strong>OR 1=1</strong> payload isn&#39;t reliable in situations where the App expected only 1 row returned from a query.</p><p></p><p>A better payload includes a <strong>LIMIT</strong> clause. If the App only expects 1 row, this will circumvent the issue, but it should also work wherever the normal <strong>OR 1=1</strong> payload works.</p><p></p><p><span style="color:#060f94;text-decoration:underline;">Note</span>: There are some cases where you can&#39;t use a <strong>LIMIT</strong> clause (6:17 in video)</p><p></p><p><h3>Example SQL Code</h3></p><p>This is a segment of PHP code that utilizes a SQL query that will return multiple rows if the normal <strong>OR 1=1</strong> payload is used, causing authentication failure.</p><p></p><p><strong>$query = “SELECT * FROM users WHERE username = ‘$username’ AND password = ‘$password’”;</strong></p><p></p><p><em>&#39; OR 1=1 LIMIT 1 -- -</em></p><p></p><p><span class="subheading">Result</span>: <strong>SELECT * FROM users WHERE username = ‘</strong><em>&#39; OR 1=1 LIMIT 1 -- -</em><strong>’ AND password = ‘test’</strong></p><p></p><p><h2>Bypass Username &amp; Password</h2></p><p><span style="color:#ff0000;">Less likely to work than bypassing password alone</span>, since App may not know who it&#39;s supposed to sign in, but it varies depending on the target. However, it may default to signing you in as the 1st user, which is likely the admin.</p><p></p><p>For example, submitting the following for the username may bypass both credentials: <strong>&#39; OR 1=1-- //</strong></p><p></p><p>The Back End may then insert it into a query like the one shown below. The brown text will be treated as a comment and ignored.</p><p></p><p><strong>SELECT * FROM users WHERE username = ‘</strong><em>&#39; OR 1=1-- </em><em><span style="color:#cdab8f;">//</span></em><strong><span style="color:#cdab8f;">’ AND password = ‘</span></strong><em><span style="color:#cdab8f;">ARBITRARY</span></em><strong><span style="color:#cdab8f;">’;</span></strong></p><p></p><p><h2>Bypass Password</h2></p><p>If you know a username, then you have a higher chance of successfully bypassing the login.</p><p></p><p><strong>SELECT * FROM users WHERE username = ‘</strong><em>admin&#39; --</em><em><span style="color:#cdab8f;"> //</span></em><strong><span style="color:#cdab8f;">’ AND password = ‘</span></strong><em><span style="color:#cdab8f;">ARBITRARY</span></em><strong><span style="color:#cdab8f;">’;</span></strong></p><p></p><p><h2>★</h2><h2>Alternate Method</h2></p><p>[CTF B 153]</p><p></p><p>Sometimes ‘<strong> OR 1=1-- //</strong> doesn’t work (e.g. it could be blocked by some defenses).</p><p></p><p>In this case, you may be able to bypass the login by dropping the OR statement:  <strong>&#39;-- //</strong></p><p></p><p><h2>JSON Query</h2></p><p>[CTF</p><p>When user input is inserted into a JSON string before being passed into SQL query, there are more methods to bypass the login.</p><p></p><p><h3>Normal Methods</h3></p><p><span style="color:#ff0000;">Normal login bypass methods may still work</span>. For example, can bypass the password for bender@juice-sh.op by appending <strong>&#39;--</strong>. The HTTP Request will show your input translated into JSON like-</p><p></p><p><strong>{&quot;email&quot;:&quot;</strong><em>bender@juice-sh.op&#39;--</em><strong>&quot;,&quot;password&quot;:&quot;</strong><em>ARBITRARY</em><strong>&quot;}</strong></p><p></p><p>The Back End will then translate extract the user input and insert it into a SQL (or NoSQL) query. (Try with and without the padding referenced above. <strong>‘--</strong> vs <strong>’-- //</strong> )</p><p></p><p><strong>SELECT * FROM users WHERE username = ‘</strong><em>bender@juice-sh.op&#39; --</em><strong><span style="color:#cdab8f;">’ AND password = ‘</span></strong><em><span style="color:#cdab8f;">ARBITRARY</span></em><strong><span style="color:#cdab8f;">’;</span></strong></p><p></p><p><h3>JSON Specific Methods</h3></p><p>When JSON &amp;/or NoSQL is used, there are additional payloads to test.</p><p></p><p><h1>Tips</h1><ul><li>MySQL: Comments (i.e <strong>--</strong> ) must be followed by a space. Add padding ensure the space is preserved, like <strong>-- //</strong>. The <strong>//</strong> will be commented out, but ensure that the preceding space is interpretted.</li></ul></p></div>
</body>
</html>
